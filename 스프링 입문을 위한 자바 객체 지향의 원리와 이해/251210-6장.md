# 6장 디자인 패턴

## 어댑터 패턴 (Adapter Pattern)

호출당하는 쪽의 메소드를 호출하는 쪽의 코드에 대응하도록 중간에 어댑터를 통해 호출하는 패턴

- 쉽게 말하면 객체를 속성으로 만들어서 참조하는 디자인 패턴이다
- 사용 예시
    - 기존 코드를 수정할 수 없는데, 새로운 방식으로 사용해야 할 때
    - 외부 라이브러리나 서드파티 API를 우리 인터페이스처럼 쓰고 싶을 때
    - 서로 다른 인터페이스를 가진 객체들을 통일해서 사용하고 싶을 때
    - 인터페이스의 불일치를 해결해 객체 재사용성을 높일 때

<br>

- 어댑터 패턴이 적용되지 않은 코드

```java
public class ServiceA {
    void runServiceA() {
        System.print.out("ServiceA");
    }
}

public class ServiceB {
    void runServiceB() {
        System.print.out("ServiceB");
    }
}

public class ClientWithNoAdapter {
    public static void main(String[] args) {
        ServiceA sa = new ServiceA();
        ServiceB sb = new ServiceB();

        sa.runServiceA();
        sb.runServiceB();
    }
}
```

- 어댑터 패턴이 적용된 코드

```java
// ServiceA, ServiceB는 그대로 있다고 가정

public class AdapterServiceA {
    ServiceA sa = new ServiceA();

    void runService() {
        sa.runServiceA();
    }
}

public class AdapterServiceB {
    ServiceA sb = new ServiceB();

    void runService() {
        sb.runServiceB();
    }
}

public class ClientWithAdapter {
    public static void main(String[] args) {
        AdapterServiceA asa = new AdapterServiceA();
        AdapterServiceB asb = new AdapterServiceB();

        asa.runService();
        asb.runService();
    }
}
```

## 프록시 패턴 (Proxy Pattern)

제어 흐름을 조정하기 위한 목적으로 중간에 대리자를 두는 패턴

- 실제 객체를 감싸서 대신 요청을 처리하는 구조
- 사용 예시
    - 객체 생성 비용이 클 때 (지연 로딩)
    - 접근 제어가 필요할 때
    - 부가기능을 삽입하고 싶을 때
- 프록시 패턴의 중요 포인트
    - 대리자는 실제 서비스와 같은 이름의 메소드를 구현하며, 이때 인터페이스를 사용한다
    - 대리자는 실제 서비스에 대한 참조 변수를 갖는다
    - 대리자는 실제 서비스의 같은 이름을 가진 메소드를 호출하고 그 값을 클라이언트에게 돌려준다
    - 대리자는 실제 서비스의 메소드 호출 전후에 별도의 로직을 수행할 수도 있다

<br>

- 프록시 패턴이 적용되지 않은 코드

```java
public class Service {
    public String run() {
        return "서비스";
    }
}

public class ClientWithNoProxy {
    Service service = new Service();
    System.out.println(service.run());
}
```

- 프록시 패턴이 적용된 코드

```java
public Interface IService {
    String run();
}

public class Service implements IService {
    public String run() {
        return "서비스";
    }
}

public class Proxy implements IService {
    IService service;

    public String run() {
        service = new Service();
        return service.run();
    }
}

public class ClientWithProxy {
    public static void main(String[] args) {
        IService proxy = new Proxy();
        System.out.println(proxy.run());
    }
}
```

## 데코레이터 패턴 (Decorator Pattern)

메소드 호출의 반환값에 변화를 주기 위해 중간에 장식자를 두는 패턴

- 데코레이터 패턴은 프록시 패턴과 구현 방법이 같으나, 프록시 패턴은 클라이언트가 돌려 받는 반환값을 조작하지 않고 그대로 전달하는 반면 데코레이터 패턴은 클라이언트가 받는 반환값에 장식을 덧입힌다
- 사용 예시
    - 상속으로 기능 확장이 어렵거나 너무 많아질 때
    - 실행 중(runtime)에 유연하게 기능을 추가/제거할 때
    - 기존 코드를 수정하지 않고 기능을 붙이고 싶은 경우
- 데코레이터 패턴의 중요 포인트
    - 장식자는 실제 서비스와 같은 이름의 메소드를 구현하며, 이때 인터페이스를 사용한다
    - 장식자는 실제 서비스에 대한 참조 변수를 가진다
    - 장식자는 실제 서비스와 같은 이름을 가진 메소드를 호출하고, 그 반환값에 장식을 더해 클라이언트에게 돌려준다
    - 장식자는 실제 서비스의 메소드 호출 전후에 별도의 로직을 수행할 수도 있다

<br>

- 데코레이터 패턴이 적용된 코드

```java
public Interface IService {
    String run();
}

public class Service implements IService {
    public String run() {
        return "서비스";
    }
}

public class Decorator implements IService {
    IService service;

    public String run() {
        service = new Service();
        return "장식 추가" + service.run();
    }
}

public class ClientWithProxy {
    public static void main(String[] args) {
        IService decorator = new Decorator();
        System.out.println(decorator.run());
    }
}
```

## 싱글톤 패턴 (Singleton Pattern)

객체를 하나만 만들어 사용하는 패턴

- 무거운 객체를 여러 개 생성하면 불필요한 자원을 사용하므로 하나만 만들어서 사용한다
- 싱글톤 패턴의 꼭 필요한 요소
    - new를 실행할 수 없도록 생성자에 private 접근 제어자를 지정한다
    - 유일한 단일 객체를 반환할 수 있는 정적 메소드가 필요하다
    - 유일한 단일 객체를 참조할 정적 참조 변수가 필요하다
-  싱글톤 패턴의 중요 포인트
    - private 생성자를 가진다
    - 단일 객체 참조 변수를 정적 속성으로 갖는다
    - 단일 객체 참조 변수가 참조하는 단일 객체를 반환하는 getInstance() 정적 메소드를 갖는다
    - 단일 객체는 쓰기 가능한 속성을 갖지 않는 것이 정석이다

<br>

- 싱글톤 패턴이 적용된 코드

```java
public class Singleton {
    static Singleton = singletonObject; // 정적 참조 변수

    private Singleton() {}; // private 생성자

    // 객체 반환 정적 메소드
    public static Singleton getInstance() {
        if (singletonObject == null) {
            singletonObject = new Singleton();
        }

        return singletonObject;
    }
}

public class Client {
    public static void main (String[] args) {
        Singleton s1 = Singleton.getInstance();
        Singleton s2 = Singleton.getInstance();
        Singleton s3 = Singleton.getInstance();

        /*
            소스 코드
        */
    }
}
```

## 템플릿 메소드 패턴 (Template Method Pattern)

상위 클래스의 견본 메소드가 하위 클래스가 오버라이딩한 메소드를 호출하는 패턴

- 상위 클래스에 공통 로직을 수행하는 템플릿 메소드에 하위 클래스에 로버라이딩을 강제하는 추상 메소드 또는 선택적으로 오버라이딩 할 수 있는 훅 메소드를 두는 패턴
- 사용 예시
    - 알고리즘은 같지만, 일부 단계만 다를 때
    - 중복되는 코드를 부모에서 한 번만 정의하고, 변해야 하는 부분만 자식이 구현
    - 전체 알고리즘의 흐릉을 통제하고 싶은 경우

<br>

- 템플릿 메소드 패턴이 적용된 코드

```java
public abstract class Animal {
    // 템플릿 메소드
    public void playWithOwner() {
        play();
        run();
    }

    // 추상 메소드
    abstract void play();

    // Hook(갈고리) 메소드
    void run() {
        System.out.println("꼬리 살랑 살랑");
    }
}

public class Dog extends Animal {
    @Overriding
    // 추상 메소드 오버라이딩
    void play() {
        System.out.println("멍 멍");
    }

    // Hook 메소드 오버라이딩
    @Overriding
    void run() {
        System.out.println("멍 멍 꼬리 살랑 살랑");
    }
}

public class Cat extends Animal {
    @Overriding
    // 추상 메소드 오버라이딩
    void play() {
        System.out.println("야옹 야옹");
    }

    // Hook 메소드 오버라이딩
    @Overriding
    void run() {
        System.out.println("야옹 야옹 꼬리 살랑 살랑");
    }
}

public class Driver {
    public static void main(String[] args) {
        Animal dog = new Dog();
        Animal cat = new Cat():

        dog.playWithOwner();
        cat.playWithOwner();
    }
}
```

## 팩토리 메소드 패턴 (Factory Method Pattern)

오버라이딩된 메소드가 객체를 반환하는 패턴

- 팩토리 메소드는 객체를 생성해 반환하는 메소드를 말한다
- 팩토리 메소드 패턴은 하위 클래스에서 팩토리 메소드를 오버라이딩해서 객체를 반환하게 하는 것을 의미한다
- 객체 생성의 책임을 서브클래스에게 넘겨, 객체 생성 코드를 캡슐화하고 유연하게 만드는 생성 패턴

<br>

- 팩토리 메소드가 적용된 코드

```java
public abstract class Animal {
    // 추상 팩토리 메소드
    abstract AnimalToy getToy();
}

// 팩토리 메소드가 생성할 객체의 상위 클래스
public abstract class AnimalToy {
    abstract void identify();
}

public class Dog extends Animal {
    // 추상 팩토리 메소드 오버라이딩
    @Override
    AnimalToy getToy() {
        return new DogToy();
    }
}

public class Cat extends Animal {
    // 추상 팩토리 메소드 오버라이딩
    @Override
    AnimalToy getToy() {
        return new CatToy();
    }
}

public class DogToy extends AnimalToy {
    public void identify() {
        System.out.println("강아지 장난감");
    }
}

public class CatToy extends AnimalToy {
    public void identify() {
        System.out.println("고양이 장난감");
    }
}

public class Driver {
    public static void main(String[] args) {
        // 팩토리 메소드를 보유한 객체들 생성
        Animal dog = new Dog();
        Animal cat = new Cat();

        // 팩토리 메소드가 반환하는 객체들
        AnimalToy dogToy = dog.getToy();
        AnimalToy catToy = cat.getToy();

        // 팩토리 메소드가 반환한 객체들을 사용
        dog.identify();
        cat.identify();
    }
}
```

## 전략 패턴 (Strategy Pattern)

클라이언트가 전략을 생성해 전략을 실행할 컨텍스트에 주입하는 패턴

- 전략 패턴을 구성하는 요소
    - 전략 메소드를 가진 객체
    - 전략 객체를 사용하는 컨텍스트(전략 객체의 사용자)
    - 전략 객체를 생성해 컨텍스트에 ㅜ입하는 클라이언트(제3자, 전략 객체의 공급자)
- 사용 예시
    - if/switch로 알고리즘을 분기하는 코드가 복잡해질 때
    - 알고리즘이 자주 변경되거나 교체될 가능성이 있을 때
    - 실행 중(runtime)에 알고리즘을 교체하고 싶을 때
- 템플릿 메소드 패턴과 유사한데, 같은 문제의 해결책으로 상속을 이요하는 템플릿 메소드 패턴과 객체 주입을 통한 전략 패턴 중에서 선택/적용할 수 있다
- 단일 상속만이 가능한 자바에서는 전략 패턴이 더 많이 사용된다

<br>

- 전략 패턴이 적용된 코드

```java
public interface Strategy {
    void runStrategy();
}

public class Gun implements Strategy {
    @Override
    public void runStrategy() {
        System.out.println("탕 탕 탕");
    }
}

public class Gun implements Strategy {
    @Override
    public void run Strategy() {
        System.out.println("탕 탕 탕");
    }
}

public class Sword implements Strategy {
    @Override
    public void run Strategy() {
        System.out.println("챙 챙 챙");
    }
}

public class Bow implements Strategy {
    @Override
    public void run Strategy() {
        System.out.println("슝 슝 슝");
    }
}

public class Soldier {
    void runContext(Strategy strategy) {
        strategy.runStrategy();
    }
}

public class Client {
    public static void main(String[] args) {
        Strategy strategy = null;
        Soldier rambo = new Soldier();

        // 총
        strategy = new Gun();
        rambo.runContext(strategy);

        // 검
        strategy = new Sword();
        rambo.runContext(strategy);

        // 활
        strategy = new Bow();
        rambo.runContext(strategy);
    }
}
```

## 템플릿 콜백 패턴 (Template)

전략을 익명 내부 클래스로 구현한 전략 패턴

- 전략 패턴과 모든 것이 동일한데 전략을 익명 내부 클래스로 정의해서 사용한다
- 공통 흐름을 가진 템플릿에, 변하는 부분을 콜백(전략)으로 전달해 실행하는 패턴으로, 상속 기반 템플릿 메소드의 단점을 해결한 유연한 구조이다

<br>

- 템플릿 콜백 패턴이 적용된 코드 (전략 패턴 코드 참고)

```java
public interface Strategy {
    void runStrategy();
}

public class Soldier {
    void runContext(String weapon) {
        executeWeapon(weapon).runStrategy();
    }

    private Strategy executeWeapon(final String weapon) {
        return new Strategy() {
            @Override
            public void runStrategy() {
                System.out.println(weapon);
            }
        }
    }
}

public class Client {
    public static void main(String[] args) {
        Soldier rambo = new Soldier();

        rambo.runContext("탕 탕 탕");

        rambo.runContext("챙 챙 챙");

        rambo.runContext("슝 슝 슝");
    }
}
```