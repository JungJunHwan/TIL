# GoF (Gang of Four) 디자인 패턴

## 행동

### 전략 패턴 (Strategy Pattern)

- 로직 군을 정의하고 각각을 캡슐화하여 교체 가능하게 만드는 패턴
- 무엇을 할지와 어떻게 할지를 분리하여, 코드를 변경하지 않고도 기능을 확장할 수 있다(OCP 원칙)

<br>

패턴이 적용되지 않은 코드
- 새로운 결제 방식(예: 카카오페이)이 추가될 때마다 기존 `PayService` 코드를 수정해야 합니다. `if-else`가 계속 길어집니다.

```java
class PayService {
    public void pay(String method, int amount) {
        if (method.equals("CREDIT_CARD")) {
            System.out.println("신용카드로 " + amount + "원 결제합니다.");
        } else if (method.equals("PAYPAL")) {
            System.out.println("페이팔로 " + amount + "원 결제합니다.");
        } else {
            System.out.println("지원하지 않는 결제 방식입니다.");
        }
        // 새로운 결제 방식이 추가되면 여기를 또 수정해야 함 (OCP 위반)
    }
}

public class Main {
    public static void main(String[] args) {
        PayService service = new PayService();
        service.pay("CREDIT_CARD", 10000);
    }
}
```

<br>

패턴이 적용된 코드
- 결제 방식을 인터페이스로 추상화합니다. 새로운 결제 방식이 생겨도 기존 코드는 건드리지 않고 클래스만 추가하면 됩니다.

```java
// 1. 전략 인터페이스 정의
interface PaymentStrategy {
    void pay(int amount);
}

// 2. 구체적인 전략 구현 (신용카드)
class CreditCardStrategy implements PaymentStrategy {
    @Override
    public void pay(int amount) {
        System.out.println("신용카드로 " + amount + "원 결제합니다.");
    }
}

// 2. 구체적인 전략 구현 (페이팔)
class PaypalStrategy implements PaymentStrategy {
    @Override
    public void pay(int amount) {
        System.out.println("페이팔로 " + amount + "원 결제합니다.");
    }
}

// 3. 컨텍스트 (전략을 사용하는 곳)
class PayService {
    private PaymentStrategy strategy;

    // 전략을 주입받음 (교체 가능)
    public void setStrategy(PaymentStrategy strategy) {
        this.strategy = strategy;
    }

    public void processPay(int amount) {
        strategy.pay(amount);
    }
}

// 메인 실행
public class Main {
    public static void main(String[] args) {
        PayService service = new PayService();

        // 상황에 따라 전략을 갈아끼움
        service.setStrategy(new CreditCardStrategy());
        service.processPay(10000); // 신용카드 결제

        service.setStrategy(new PaypalStrategy());
        service.processPay(20000); // 페이팔 결제
    }
}
```

### 옵저버 패턴 (Observer Pattern)

- 정의
    - 객체의 상태 변화를 관찰하는 관찰자들에게, 상태가 변할 때마다 자동으로 알림을 보내는 패턴

<br>

패턴이 적용되지 않은 코드
- 유튜버(Subject)가 새로운 구독자가 생길 때마다 코드를 수정해서 알림 로직을 추가해야 합니다.

```java
class UserA {
    public void alarm() { System.out.println("UserA: 영상 올라왔다!"); }
}
class UserB {
    public void alarm() { System.out.println("UserB: 영상 올라왔다!"); }
}

class Youtuber {
    private UserA userA;
    private UserB userB;

    public void uploadVideo() {
        System.out.println("영상 업로드 완료");
        
        // 구독자가 늘어날 때마다 변수 추가하고, 여기 호출 코드를 계속 추가해야 함 (강한 결합)
        if(userA != null) userA.alarm();
        if(userB != null) userB.alarm();
    }
    
    public void setUserA(UserA userA) { this.userA = userA; }
    public void setUserB(UserB userB) { this.userB = userB; }
}
```

<br>

패턴이 적용된 코드
- 구독자들을 Observer라는 공통 인터페이스로 묶어서 관리합니다. 유튜버는 리스트(List)만 반복문을 돌리면 되고, 구독자가 누구인지 구체적으로 알 필요가 없습니다.

```java
import java.util.ArrayList;
import java.util.List;

// 1. 관찰자 인터페이스 (구독자 공통 규격)
interface Observer {
    void update(String msg);
}

// 2. 구체적인 관찰자들
class Subscriber implements Observer {
    private String name;
    public Subscriber(String name) { this.name = name; }

    @Override
    public void update(String msg) {
        System.out.println(name + " 수신: " + msg);
    }
}

// 3. 주체 (유튜버)
class Youtuber {
    // 구독자 리스트
    private List<Observer> subscribers = new ArrayList<>();

    // 구독 (리스트 추가)
    public void subscribe(Observer observer) {
        subscribers.add(observer);
    }

    // 구독 취소 (리스트 삭제)
    public void unsubscribe(Observer observer) {
        subscribers.remove(observer);
    }

    // 알림 보내기 (리스트 순회)
    public void notifySubscribers(String msg) {
        for (Observer observer : subscribers) {
            observer.update(msg);
        }
    }

    public void uploadVideo(String title) {
        System.out.println("'" + title + "' 영상 업로드!");
        notifySubscribers("새 영상이 올라왔습니다: " + title);
    }
}

public class Main {
    public static void main(String[] args) {
        Youtuber myChannel = new Youtuber();

        Subscriber s1 = new Subscriber("철수");
        Subscriber s2 = new Subscriber("영희");

        myChannel.subscribe(s1);
        myChannel.subscribe(s2);

        myChannel.uploadVideo("디자인 패턴 강의"); 
        // 철수, 영희 모두 알림 받음

        myChannel.unsubscribe(s1); // 철수 구독 취소
        myChannel.uploadVideo("자바 강의"); 
        // 영희만 알림 받음
    }
}
```

### 템플릿 메소드 패턴 (Template Method Pattern)

- 정의
    - 알고리즘의 전체 구조를 부모 클래스에서 정의하고, 구체적인 단계(세부 구현)는 자식 클래스에서 재정의하는 패턴

<br>

패턴이 적용되지 않은 코드
- `SinRamen`과 `JinRamen` 클래스에 물을 끓이거나 그릇에 담는 중복된 코드가 존재합니다.

```java
class SinRamen {
    public void cook() {
        System.out.println("물을 끓인다."); // 중복
        System.out.println("매운 스프를 넣는다.");
        System.out.println("면을 넣고 끓인다."); // 중복
    }
}

class JinRamen {
    public void cook() {
        System.out.println("물을 끓인다."); // 중복
        System.out.println("순한 스프를 넣는다.");
        System.out.println("면을 넣고 끓인다."); // 중복
    }
}
```

<br>

패턴이 적용된 코드
- 공통된 과정은 부모 클래스(`Ramen`)에 두고, 달라지는 부분(`addSoup`)만 추상 메서드로 만들어 자식이 구현하게 합니다. `cook()` 메서드가 바로 템플릿 메서드입니다.

```java
// 1. 추상 클래스 (알고리즘의 뼈대)
abstract class Ramen {
    // 템플릿 메서드: 전체 흐름을 정의 (자식이 구조를 못 바꾸게 final 권장)
    public final void cook() {
        boilWater();
        addSoup(); // 이 부분만 다름 (Hook 또는 추상 메서드)
        addNoodles();
    }

    private void boilWater() { System.out.println("물을 끓인다."); }
    private void addNoodles() { System.out.println("면을 넣고 3분간 끓인다."); }

    // 자식마다 다르게 구현해야 하는 부분
    abstract void addSoup();
}

// 2. 구체적인 클래스들
class SinRamen extends Ramen {
    @Override
    void addSoup() { System.out.println("표고버섯 건더기와 매운 스프 투하!"); }
}

class JinRamen extends Ramen {
    @Override
    void addSoup() { System.out.println("야채 건더기와 순한 스프 투하!"); }
}

// 메인 실행
public class Main {
    public static void main(String[] args) {
        Ramen myLunch = new SinRamen();
        myLunch.cook();
        // 출력:
        // 물을 끓인다.
        // 표고버섯 건더기와 매운 스프 투하!
        // 면을 넣고 3분간 끓인다.
    }
}
```

###  커맨드 패턴 (Command Pattern)

- 정의
    - 요청을 객체의 형태로 캡슐화하여, 실행될 기능을 나중에 지정하거나, 요청을 큐에 저장하거나, 실행 취소 기능을 구현할 수 있게 하는 패턴

<br>

패턴이 적용되지 않은 코드
- 리모컨(RemoteControl)이 전등(Light)이라는 구체적인 클래스에 강하게 결합되어 있습니다. 만약 히터(Heater)를 켜는 버튼으로 바꾸려면 리모컨 코드를 뜯어고쳐야 합니다.

```java
class Light {
    void turnOn() { System.out.println("전등 켜짐"); }
}

class RemoteControl {
    private Light light; // 전등밖에 제어 못함

    public RemoteControl(Light light) {
        this.light = light;
    }

    public void pressButton() {
        light.turnOn(); // 다른 기기로 바꾸려면 코드를 수정해야 함
    }
}
```

<br>

패턴이 적용된 코드
- `Command` 인터페이스를 통해 리모컨과 전등 사이의 결합을 끊습니다. 리모컨은 `execute()`만 호출하면 됩니다. 이제 리모컨 코드를 수정하지 않고도 히터, TV 등으로 기능을 갈아끼울 수 있습니다.

```java
// 1. 커맨드 인터페이스 (명령의 규격)
interface Command {
    void execute();
}

// 2. 리시버 (실제 동작을 수행하는 객체)
class Light {
    void turnOn() { System.out.println("전등 켜짐"); }
}
class Heater {
    void powerOn() { System.out.println("히터 가동"); }
}

// 3. 구체적인 커맨드 (주문서)
class LightOnCommand implements Command {
    private Light light;
    public LightOnCommand(Light light) { this.light = light; }
    
    @Override
    public void execute() { light.turnOn(); } // 실제 행동 연결
}

class HeaterOnCommand implements Command {
    private Heater heater;
    public HeaterOnCommand(Heater heater) { this.heater = heater; }
    
    @Override
    public void execute() { heater.powerOn(); }
}

// 4. 인보커 (호출자, 리모컨)
class RemoteControl {
    private Command command; // 무엇이든 들어올 수 있음

    public void setCommand(Command command) {
        this.command = command;
    }

    public void pressButton() {
        command.execute(); // 버튼은 내용도 모른 채 실행만 함
    }
}

// 메인 실행
public class Main {
    public static void main(String[] args) {
        RemoteControl remote = new RemoteControl();
        Light light = new Light();
        Heater heater = new Heater();

        // 1. 전등 켜기 기능 탑재
        remote.setCommand(new LightOnCommand(light));
        remote.pressButton();

        // 2. 히터 켜기 기능으로 교체 (리모컨 코드 수정 없음)
        remote.setCommand(new HeaterOnCommand(heater));
        remote.pressButton();
    }
}
```

### 상태 패턴 (State Pattern)

- 정의
    - 객체의 내부 상태가 바뀜에 따라 객체의 행동을 변경하는 패턴
    - 상태를 별도의 클래스로 분리하여, 마치 객체의 클래스가 바뀐 것처럼 동작하게 한다

<br>

패턴이 적용되지 않은 코드
- 상태가 늘어날수록 `if-else`문이 기하급수적으로 늘어납니다. 새로운 상태(예: 취침 모드)를 추가하려면 모든 메서드를 다 뒤져서 `else if`를 추가해야 합니다.

```java
class Laptop {
    public static final int OFF = 0;
    public static final int ON = 1;
    private int state = OFF;

    public void powerPush() {
        if (state == OFF) {
            System.out.println("전원 켜짐");
            state = ON;
        } else if (state == ON) {
            System.out.println("전원 꺼짐");
            state = OFF;
        }
    }
    
    public void typePush() {
        if (state == OFF) {
            System.out.println("반응 없음 (전원 꺼져있음)");
        } else if (state == ON) {
            System.out.println("키보드 입력 중...");
        }
    }
}
```

<br>

패턴이 적용된 코드
- 각 상태를 클래스로 나눕니다. `Laptop`은 현재 상태 객체에게 행동을 위임하기만 하면 됩니다. 조건문이 싹 사라집니다.

```java
// 1. 상태 인터페이스
interface LaptopState {
    void powerPush(Laptop laptop);
    void typePush(Laptop laptop);
}

// 2. 구체적인 상태들
class OffState implements LaptopState {
    @Override
    public void powerPush(Laptop laptop) {
        System.out.println("전원 켜짐");
        laptop.setState(new OnState()); // 상태 전환
    }
    @Override
    public void typePush(Laptop laptop) {
        System.out.println("반응 없음 (전원 꺼져있음)");
    }
}

class OnState implements LaptopState {
    @Override
    public void powerPush(Laptop laptop) {
        System.out.println("전원 꺼짐");
        laptop.setState(new OffState()); // 상태 전환
    }
    @Override
    public void typePush(Laptop laptop) {
        System.out.println("키보드 입력 중...");
    }
}

// 3. 컨텍스트 (노트북)
class Laptop {
    private LaptopState state;

    public Laptop() {
        this.state = new OffState(); // 초기 상태
    }

    public void setState(LaptopState state) {
        this.state = state;
    }

    // 행동을 현재 상태 객체에게 위임
    public void powerPush() { state.powerPush(this); }
    public void typePush() { state.typePush(this); }
}

// 메인 실행
public class Main {
    public static void main(String[] args) {
        Laptop laptop = new Laptop();
        
        laptop.typePush();  // OffState 동작: "반응 없음"
        laptop.powerPush(); // OffState 동작 -> OnState로 전환
        laptop.typePush();  // OnState 동작: "키보드 입력 중..."
    }
}
```

### 이터레이터 패턴 (Iterator Pattern)

- 정의
    - 컬렉션(List, Array, Stack 등)의 내부 구현 방식을 노출하지 않으면서, 그 안에 들어있는 모든 요소에 순차적으로 접근할 수 있게 하는 패턴

<br>

패턴이 적용되지 않은 코드
- 컬렉션의 종류(배열 vs 리스트)에 따라 순회하는 방식이 달라집니다. 클라이언트가 내부 구조를 다 알아야 합니다.

```java
import java.util.ArrayList;

class BookShelf {
    private String[] books = {"해리포터", "반지의제왕", "호빗"}; // 배열로 구현됨
    public String[] getBooks() { return books; }
}

class EBookShelf {
    private ArrayList<String> books = new ArrayList<>(); // 리스트로 구현됨
    public void add(String book) { books.add(book); }
    public ArrayList<String> getBooks() { return books; }
}

public class Main {
    public static void main(String[] args) {
        // 1. 배열일 때
        BookShelf shelf = new BookShelf();
        for (int i = 0; i < shelf.getBooks().length; i++) {
            System.out.println(shelf.getBooks()[i]);
        }

        // 2. 리스트일 때 (순회 방식 코드가 다름)
        EBookShelf eShelf = new EBookShelf();
        eShelf.add("자바의 정석");
        for (int i = 0; i < eShelf.getBooks().size(); i++) {
            System.out.println(eShelf.getBooks().get(i));
        }
        // 자료구조가 바뀔 때마다 클라이언트 코드(for문)를 수정해야 함
    }
}
```

<br>

패턴이 적용된 코드
- `Iterator`라는 공통 인터페이스를 통해 접근합니다. 배열이든 리스트든 `hasNext()`와 `next()`만 있으면 똑같이 순회할 수 있습니다.

```java
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

// 1. 집합체 인터페이스 (Iterator를 만들어내는 공장)
interface Aggregate {
    Iterator<String> createIterator();
}

// 2. 구체적인 집합체 (배열 사용)
class BookShelf implements Aggregate {
    private String[] books = {"해리포터", "반지의제왕", "호빗"};

    @Override
    public Iterator<String> createIterator() {
        return new BookShelfIterator(this); // 전용 반복자 반환
    }
    
    public String getBookAt(int index) { return books[index]; }
    public int getLength() { return books.length; }
}

// 3. 반복자 (Iterator) 구현 - 배열용
class BookShelfIterator implements Iterator<String> {
    private BookShelf bookShelf;
    private int index = 0;

    public BookShelfIterator(BookShelf bookShelf) {
        this.bookShelf = bookShelf;
    }

    @Override
    public boolean hasNext() {
        return index < bookShelf.getLength();
    }

    @Override
    public String next() {
        return bookShelf.getBookAt(index++);
    }
}

// 메인 실행
public class Main {
    public static void main(String[] args) {
        BookShelf shelf = new BookShelf();
        
        // 클라이언트는 내부가 배열인지 리스트인지 모름. Iterator만 있으면 됨.
        Iterator<String> it = shelf.createIterator();
        
        while (it.hasNext()) {
            System.out.println(it.next());
        }
    }
}
```

### 책임 연쇄 패턴 (Chain of Responsibility Pattern)

- 정의
    - 요청을 보내는 쪽과 받는 쪽을 분리하기 위해, 요청을 처리할 수 있는 기회를 여러 객체에게 순서대로 주는 패턴

<br>

패턴이 적용되지 않은 코드
- 클라이언트가 "누가 이 문제를 처리해야 하는지" 정확히 알고 분기해야 하거나, 하나의 메서드에 모든 처리 로직이 뭉쳐 있습니다.

```java
class TroubleShooter {
    public void solve(String difficulty) {
        if (difficulty.equals("easy")) {
            System.out.println("신입 사원이 간단히 해결함.");
        } else if (difficulty.equals("normal")) {
            System.out.println("대리가 해결함.");
        } else if (difficulty.equals("hard")) {
            System.out.println("팀장이 나서서 해결함.");
        } else {
            System.out.println("해결 불가능...");
        }
    }
}
```

<br>

패턴이 적용된 코드
- 각 담당자를 객체로 나누고 사슬(Chain)처럼 연결합니다. 요청을 `start`에만 넣으면 알아서 흘러갑니다.

```java
// 1. 핸들러 추상 클래스 (다음 사람을 가리키는 포인터 포함)
abstract class Support {
    private Support next; // 다음 타자

    public Support setNext(Support next) {
        this.next = next;
        return next; // 체이닝을 위해 반환
    }

    public void solve(String difficulty) {
        if (canHandle(difficulty)) {
            process();
        } else if (next != null) {
            next.solve(difficulty); // 내가 못 하면 다음 사람에게 넘김
        } else {
            System.out.println("아무도 해결할 수 없는 문제입니다.");
        }
    }

    protected abstract boolean canHandle(String difficulty);
    protected abstract void process();
}

// 2. 구체적인 핸들러들
class Rookie extends Support {
    protected boolean canHandle(String difficulty) { return difficulty.equals("easy"); }
    protected void process() { System.out.println("신입 사원이 해결!"); }
}

class Manager extends Support {
    protected boolean canHandle(String difficulty) { return difficulty.equals("normal"); }
    protected void process() { System.out.println("과장님이 해결!"); }
}

class Director extends Support {
    protected boolean canHandle(String difficulty) { return difficulty.equals("hard"); }
    protected void process() { System.out.println("이사님이 해결!"); }
}

// 메인 실행
public class Main {
    public static void main(String[] args) {
        Support rookie = new Rookie();
        Support manager = new Manager();
        Support director = new Director();

        // 사슬 연결: 신입 -> 과장 -> 이사
        rookie.setNext(manager).setNext(director);

        System.out.println("--쉬운 문제--");
        rookie.solve("easy"); 

        System.out.println("--어려운 문제--");
        rookie.solve("hard"); // 신입(X) -> 과장(X) -> 이사(O)
    }
}
```

### 중재자 패턴 (Mediator Pattern)

- 정의
    - 객체들 간의 복잡한 m:n 통신 관계를 1:n 관계로 바꿔주는 중재자를 두는 패턴
    - 객체끼리 서로 직접 소통하지 않고, 무조건 중재자를 통해서만 소통하게 된다

<br>

패턴이 적용되지 않은 코드
- 채팅방에 사람이 3명(A, B, C) 있으면, A는 B와 C를 알아야 하고, B도 A와 C를 알아야 합니다. (참조 관계 복잡)

```java
class User {
    private String name;
    // 다른 친구들을 다 알고 있어야 함 (결합도 높음)
    private User friend1; 
    private User friend2; 

    public void sendMessage(String msg) {
        System.out.println(name + " 보냄: " + msg);
        if(friend1 != null) friend1.receive(msg);
        if(friend2 != null) friend2.receive(msg);
    }
    public void receive(String msg) { ... }
}
```

<br>

패턴이 적용된 코드
- `User`는 오직 `ChatMediator`만 알고 있습니다. 메시지를 보내면 중재자가 알아서 다른 사람들에게 뿌려줍니다.

```java
import java.util.ArrayList;
import java.util.List;

// 1. 중재자 인터페이스
interface ChatMediator {
    void sendMessage(String msg, User user);
    void addUser(User user);
}

// 2. 구체적인 중재자 (채팅방)
class ChatRoom implements ChatMediator {
    private List<User> users = new ArrayList<>();

    @Override
    public void addUser(User user) { users.add(user); }

    @Override
    public void sendMessage(String msg, User sender) {
        // 보낸 사람을 제외한 모든 사람에게 전송
        for (User user : users) {
            if (user != sender) {
                user.receive(msg);
            }
        }
    }
}

// 3. 참여자 (Colleague)
abstract class User {
    protected ChatMediator mediator;
    protected String name;

    public User(ChatMediator mediator, String name) {
        this.mediator = mediator;
        this.name = name;
    }
    
    // 중재자에게 전송 요청
    public void send(String msg) {
        System.out.println(this.name + " 발신: " + msg);
        mediator.sendMessage(msg, this);
    }
    
    public abstract void receive(String msg);
}

class ChatUser extends User {
    public ChatUser(ChatMediator mediator, String name) { super(mediator, name); }

    @Override
    public void receive(String msg) {
        System.out.println(this.name + " 수신: " + msg);
    }
}

// 메인 실행
public class Main {
    public static void main(String[] args) {
        ChatMediator chatRoom = new ChatRoom();

        User u1 = new ChatUser(chatRoom, "철수");
        User u2 = new ChatUser(chatRoom, "영희");
        User u3 = new ChatUser(chatRoom, "민수");

        chatRoom.addUser(u1);
        chatRoom.addUser(u2);
        chatRoom.addUser(u3);

        // 철수가 말을 하면 -> 중재자가 영희, 민수에게 전달
        u1.send("안녕하세요!"); 
    }
}
```

### 메멘토 패턴 (Memento Pattern)

- 정의
    - 객체의 내부 상태를 캡슐화를 깨지 않고 저장했다가, 나중에 이전 상태로 복구할 수 있게 해주는 패턴
    - 핵심은 객체의 내부 정보를 외부에 직접 노출하지 않으면서도 저장한다는 것

<br>

패턴이 적용되지 않은 코드
- 이전 상태로 돌아가기 위해 `GameUser`의 `level` 변수에 직접 접근해야 합니다. 만약 저장해야 할 변수가 수십 개라면 관리가 불가능해집니다.

```java
class GameUser {
    // 외부에서 상태를 저장하려면 public으로 열어야 함 (보안/캡슐화 위반)
    public int level; 
    public String weapon;

    public GameUser(int level, String weapon) {
        this.level = level;
        this.weapon = weapon;
    }
}

public class Main {
    public static void main(String[] args) {
        GameUser user = new GameUser(10, "Sword");
        
        // 상태 저장 (클라이언트가 일일이 변수를 백업해야 함)
        int backupLevel = user.level;
        String backupWeapon = user.weapon;

        // 레벨업 및 무기 변경
        user.level = 20;
        user.weapon = "Gun";

        // 복구
        user.level = backupLevel;
        user.weapon = backupWeapon;
    }
}
```

<br>

패턴이 적용된 코드
- `Memento` 클래스에 상태를 얼려서 보관합니다. `GameUser`는 스스로 `save()`하여 메멘토를 뱉어내고, `restore()`를 통해 복구합니다. 외부는 메멘토 안에 뭐가 들었는지 알 필요가 없습니다.

```java
// 1. 메멘토 (저장된 상태 객체)
class Memento {
    private final int level;   // 불변(final)으로 만드는 것이 좋음
    private final String weapon;

    public Memento(int level, String weapon) {
        this.level = level;
        this.weapon = weapon;
    }

    public int getLevel() { return level; }
    public String getWeapon() { return weapon; }
}

// 2. 오리지네이터 (상태를 가진 실제 객체)
class GameUser {
    private int level;
    private String weapon;

    public GameUser(int level, String weapon) {
        this.level = level;
        this.weapon = weapon;
    }

    public void setInfo(int level, String weapon) {
        this.level = level;
        this.weapon = weapon;
        System.out.println("현재 상태: Lv." + level + ", " + weapon);
    }

    // 상태 저장: 현재 상태를 담은 메멘토 생성
    public Memento save() {
        return new Memento(this.level, this.weapon);
    }

    // 상태 복구: 메멘토를 받아서 내 상태를 되돌림
    public void restore(Memento memento) {
        this.level = memento.getLevel();
        this.weapon = memento.getWeapon();
        System.out.println("복구 완료: Lv." + level + ", " + weapon);
    }
}

// 3. 케어테이커 (메멘토를 관리하는 관리인)
class Caretaker {
    private Memento memento; // 여러 개라면 Stack<Memento> 사용 (Ctrl+Z 구현)

    public void saveMemento(Memento m) { this.memento = m; }
    public Memento getMemento() { return this.memento; }
}

public class Main {
    public static void main(String[] args) {
        GameUser user = new GameUser(10, "Sword");
        Caretaker caretaker = new Caretaker();

        // 1. 현재 상태 저장
        caretaker.saveMemento(user.save());

        // 2. 상태 변경
        user.setInfo(20, "Legendary Gun");

        // 3. 아차! 실수했다. 복구하자.
        user.restore(caretaker.getMemento());
    }
}
```

### 방문자 패턴 (Visitor Pattern)

- 정의
    - 데이터 구조와 처리를 분리하는 패턴
    - 데이터 구조(클래스)를 변경하지 않고도 새로운 연산(기능)을 추가할 수 있다
    - 객체 구조를 돌아다니는 방문자가 각 객체에 들어가서 작업을 수행
    - 더블 디스패치(Double Dispatch)라는 기법을 사용

<br>

패턴이 적용되지 않은 코드
- 새로운 기능(XML 내보내기)을 추가하려면 모든 상품 클래스를 다 열어서 `toXml()` 메서드를 추가해야 합니다. (OCP 위반)

```java
interface Item {
    int getPrice();
    // 새로운 기능이 필요할 때마다 인터페이스와 구현체를 다 수정해야 함
    // String toXml(); 
    // String toJson();
}

class Book implements Item {
    public int getPrice() { return 10000; }
}
class Fruit implements Item {
    public int getPrice() { return 2000; }
}
```

<br>

패턴이 적용된 코드
- 상품들은 `accept(Visitor v)` 문을 열어두기만 합니다. 실제 기능 구현은 `Visitor` 클래스에 모아둡니다.

```java
// 1. 방문자 인터페이스
interface Visitor {
    // 오버로딩을 통해 각 타입별로 다른 처리를 하도록 정의
    void visit(Book book);
    void visit(Fruit fruit);
}

// 2. 요소 인터페이스 (방문자를 받아들이는 곳)
interface Item {
    void accept(Visitor visitor);
}

// 3. 구체적인 요소들
class Book implements Item {
    public int getPrice() { return 10000; }
    // 핵심: 나(this)를 방문자에게 넘겨줌 (나를 처리해줘!)
    public void accept(Visitor visitor) { visitor.visit(this); }
}

class Fruit implements Item {
    public int getPrice() { return 2000; }
    public void accept(Visitor visitor) { visitor.visit(this); }
}

// 4. 구체적인 방문자 (기능 구현) - 가격 계산 기능
class PriceCalculator implements Visitor {
    private int total = 0;
    
    public void visit(Book book) {
        System.out.println("책 가격 합산");
        total += book.getPrice();
    }
    public void visit(Fruit fruit) {
        System.out.println("과일 가격 합산");
        total += fruit.getPrice();
    }
    public int getTotal() { return total; }
}

// 5. 또 다른 방문자 추가 (XML 변환 기능) - 기존 Item 클래스 수정 없음!
class XmlExporter implements Visitor {
    public void visit(Book book) { System.out.println("<book>...</book>"); }
    public void visit(Fruit fruit) { System.out.println("<fruit>...</fruit>"); }
}

public class Main {
    public static void main(String[] args) {
        Item[] items = { new Book(), new Fruit() };
        
        // 1. 가격 계산 방문자 투입
        PriceCalculator calc = new PriceCalculator();
        for(Item item : items) item.accept(calc);
        System.out.println("총합: " + calc.getTotal());

        // 2. XML 변환 방문자 투입
        XmlExporter exporter = new XmlExporter();
        for(Item item : items) item.accept(exporter);
    }
}
```

### 인터프리터 패턴 (Interpreter Pattern)

- 정의
    - 특정 언어의 문법 표현(Grammer)을 정의하고, 그 문법을 해석하는 해석기를 정의하는 패턴

<br>

패턴이 적용되지 않은 코드
- 문자열 파싱 로직을 직접 짜면 `if-else`와 문자열 자르기(`split`) 등으로 코드가 매우 복잡해지고, 새로운 연산자를 추가하기 어렵습니다.

```java
// "1 + 2" 같은 간단한 건 되지만 "1 + 2 - 3" 처럼 복잡해지면 감당 불가
class Calculator {
    public int calculate(String expression) {
        String[] tokens = expression.split(" ");
        if (tokens[1].equals("+")) {
            return Integer.parseInt(tokens[0]) + Integer.parseInt(tokens[2]);
        }
        return 0;
    }
}
```

<br>

패턴이 적용된 코드
- 문법의 각 요소(숫자, 더하기, 빼기)를 클래스로 만들어서 트리(Tree) 구조를 구성하고 재귀적으로 해석합니다.

```java
import java.util.Stack;

// 1. 표현식 인터페이스
interface Expression {
    int interpret(); // 해석(계산) 메서드
}

// 2. 터미널 표현식 (더 이상 쪼개지지 않는 요소: 숫자)
class NumberExpression implements Expression {
    private int number;
    public NumberExpression(int number) { this.number = number; }
    public int interpret() { return number; }
}

// 3. 비터미널 표현식 (연산자: 하위 표현식을 가짐) - 더하기
class AddExpression implements Expression {
    private Expression left, right;
    public AddExpression(Expression left, Expression right) {
        this.left = left;
        this.right = right;
    }
    public int interpret() {
        return left.interpret() + right.interpret();
    }
}

// 3. 비터미널 표현식 - 빼기
class MinusExpression implements Expression {
    private Expression left, right;
    public MinusExpression(Expression left, Expression right) {
        this.left = left;
        this.right = right;
    }
    public int interpret() {
        return left.interpret() - right.interpret();
    }
}

public class Main {
    public static void main(String[] args) {
        // 식: "1 + 2 - 3" 을 파싱해서 아래와 같은 객체 트리를 만들었다고 가정
        //      -
        //     / \
        //    +   3
        //   / \
        //  1   2
        
        // 트리 구축 (실제로는 파서가 문자열을 읽어 이렇게 만듦)
        Expression one = new NumberExpression(1);
        Expression two = new NumberExpression(2);
        Expression three = new NumberExpression(3);
        
        Expression add = new AddExpression(one, two); // 1 + 2
        Expression result = new MinusExpression(add, three); // (1 + 2) - 3

        // 해석 실행
        System.out.println("결과: " + result.interpret()); // 0 출력
    }
}
```