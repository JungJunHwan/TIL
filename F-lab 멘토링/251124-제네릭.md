# 제네릭 (Generic)

## 제네릭이란?

클래스나 메서드가 다룰 타입을 나중에(사용할 때) 결정할 수 있게 해주는 문법이다
컴파일 시점에 타입을 체크할 수 있어서 타입 안정성이 좋아지고, 캐스팅을 줄일 수 있고, 코드를 재사용하기 좋게 만들어준다

### 제네릭이 없을 때 발생할 수 있는 문제

- 예를 들어 리스트에 숫자를 담고 싶다고 해보자

```java
List numbers = new ArrayList(); // 제네릭 X, raw type
numbers.add(1);          // Integer
numbers.add("hello");    // String도 들어감 (컴파일러가 막지 못함)

Object o = numbers.get(0);  // 항상 Object로 나옴
Integer n = (Integer) o;    // 직접 형변환 필요
```

문제점
1. 타입 안전하지 않음
    - 리스트에 숫자만 넣으려 했는데, 실수로 `String`을 넣어도 컴파일 에러가 나지 않는다
    - 꺼낼 때 `Integer`로 캐스팅 하다가 `ClassCastException` 발생할 수 있다
2. 매번 형변환이 필요하다
    - 꺼낼 때마다 `(Integer)` 같은 캐스팅이 필요하다 -> 코드 지저분 + 실수 가능

제네릭을 사용하면 아래와 같이 변한다

```java
List<Integer> numbers = new ArrayList<>();
numbers.add(1);
// numbers.add("hello"); // 컴파일 에러!

Integer n = numbers.get(0); // 캐스팅 필요 없음
```

## 제네릭 기본 문법 - 타입 매개변수

### 제네릭 클래스

```java
public class Box<T> {
    private T value;

    public void set(T value) {
        this.value = value;
    }

    public T get() {
        return value;
    }
}
```

- `T` : 타입 매개변수
    - 관례상 `T`, `E`, `K`, `V` 같은 대문자 한 글자 사용
- 이 클래스는 어떤 타입을 담는 박스인지를 아직 모르는 상태

사용할 때 타입을 결정한다

```java
Box<String> stringBox = new Box<>();
stringBox.set("hello");
String s = stringBox.get();

Box<Integer> intBox = new Box<>();
intBox.set(10);
Integer i = intBox.get();
```

-> 같은 `Box` 코드인데, 타입만 다르게 써서 재사용

### 제네릭 메서드

클래스 전체가 제네릭이 아니더라도, 메소드만 제네릭을 만들 수 있다

```java
public class Util {
    public static <T> T getFirst(List<T> list) {
        return list.get(0);
    }
}

// 사용
List<String> names = List.of("A", "B");
String first = Util.getFirst(names);

List<Integer> nums = List.of(1, 2, 3);
Integer n = Util.getFirst(nums);

```

## 타입 매개변수 이름 관례

- `T` : Type (가장 일반적인 타입)
- `E` : Element (컬렉션 요소)
- `K` : Key
- `V` : Value
- `R` : Result

## 제한된 타입 - Bounded Type Parameter

`T`가 아무 타입인것이 아닌, 특정 타입/부모를 상속한 것만 허용하고 싶을 때 사용하는 문법

### 상한 경계 (Upper Bound) - `extends`

```java
public class NumberBox<T extends Number> {
    private T value;

    public void set(T value) {
        this.value = value;
    }

    public double toDouble() {
        return value.doubleValue(); // Number에 있는 메서드 사용 가능
    }
}
```

- `T extends Number`
    - `T`는 `Number`이거나 그 자식 타입만 가능(`Integer`, `Double` 등)
- 따라서 `value.doubleValue()` 같은 Number의 메소드를 안전하게 호출할 수 있음

### 여러 개 경계 (인터페이스 조합)

```java
public <T extends Number & Comparable<T>> T max(T a, T b) {
    return a.compareTo(b) >= 0 ? a : b;
}
```

- `T extends Number & Comparable<T>`
    - `T`는 `Number`이면서 `Comparable<T>`도 구현해야 함.
- 클래스(또는 추상 클래스) + 인터페이스 조합 가능, 맨 앞에는 반드시 클래스 / 나머지는 인터페이스.

## 와일드 카드 - ?

제네릭을 쓰다 보면 타입을 정확히 몰라도 되는데, 어느 정도 범위만 제한하고 싶은 경우가 있다.
이때 사용하는게 와일드 카드이다

### `?` - 기본 와일드카드

```java
public void printList(List<?> list) {
    for (Object o : list) {
        System.out.println(o);
    }
}
```

### `? extends T` - 상한 와일드카드 (읽기 전용에 가깝게)

```java
public double sumOfList(List<? extends Number> list) {
    double sum = 0;
    for (Number n : list) {
        sum += n.doubleValue();
    }
    return sum;
}
```

- `List<? extends Number>`
    - `List<Integer>`, `List<Double>`, `List<Long>` 등 Number의 자식 타입 리스트를 모두 받을 수 있음
- 읽기(read)는 가능
    - 요소를 꺼내면 최소한 Number라고 확신할 수 있음
- 쓰기(write)는 거의 불가능
    - list.add(10) 같은 건 컴파일 에러 (어떤 정확한 서브타입인지 모르니까)

키워드 : “extends는 주로 읽기용 – PECS 원칙에서 Producer”

### `? super T` - 하한 와일드카드 (쓰기 전용에 가깝게)

```java
public void addIntegers(List<? super Integer> list) {
    list.add(1);
    list.add(2);
}
```

- `List<? super Integer>`
    - `List<Integer>`, `List<Number>`, `List<Object>` 모두 가능.
- 쓰기(write)는 안전
    - 요소를 넣을 때 최소한 Integer는 확실하니까 넣을 수 있음.
- 읽기(read)는 Object 수준만 안전
    - 꺼낼 때는 Object로만 다뤄야 안정적.

키워드 : “super는 주로 쓰기용 – PECS 원칙에서 Consumer”

## PECS 원칙

PECS : Producer Extends, Consumer Super

- 데이터를 생산(produce)해서 꺼내는 쪽이면 -> `? extends T`
    - 예) 합계 계산 : `List<? extends Number>`
- 데이터를 소비(consume)해서 넣는 쪽이면 -> `? super T`
    - 예) 리스트에 `Integer`를 넣기 : `List<? super Integer>`

## 타입 소거(Type Ensure)

제네릭은 자바 5에서 도입됐는데, 기존 JVM과의 호환성을 유지하기 위해 컴파일 후에는 타입 정보가 대부분 사라지는 방식으로 구현됐다

```java
// 컴파일 전의 코드가 아래와 같을 때
List<String> list = new ArrayList<>();
// 컴파일 후 바이트코드 레벨에서는 다음과 같다
List list = new ArrayList();
// 따라서 런타임에는 List<String>과 List<Integer>를 구분할 수 없다

// 위의 이유로 아래와 같은 코드는 안된다
if (list instanceof List<String>) { ... } // 컴파일 에러
// 아래의 코드는 가능하다
if (list instanceof List) { ... }

// 또한 타입 소거 때문에 이런 것도 안된다
public class Box<T> {
    // static T value;          //불가능
    // new T();                 //불가능
    // T[] arr = new T[10];     //불가능
}
// 런타임 시점에 T가 뭔지 모르기 때문에 불가능하다
```

## 꼬리물기 질문

### 자바에서 제네릭을 사용하는 가장 근본적인 이유는 무엇일까?

- 컴파일 시 타입을 체크할 수 있어서 타입 안정성이 보장되고, 캐스팅을 줄이며 런타임 시점의 ClassCastException을 방지할 수 있고, 코드의 재사용성이 좋아지기 때문이다

### 타입 소거가 무엇이며 자바는 왜 런타임 제네릭을 선택하지 않고, 타입 소거 방식을 선택했는지 설명하라

- 타입 소거란 컴파일 시 제네릭 타입 정보를 체크하고 컴파일된 바이트코드에서는 타입 정보가 삭제됨을 말한다. 자바가 타입 소거를 선택한 이유는 타입 안전성을 주면서도 기존 JVM을 변경하지 않고, 과거 자바 코드와 호환되도록 하기 위해서이다

### 타입 소거 때문에 자바 제네릭에는 몇 가지 제약이 생기는데 다음이 왜 불가능한지 설명하라

1. `new T()`
    - 타입 소거 때문에, 생성자가 어떤 형태인지 알 수 없어 객체 생성이 불가능
2. `new T[]`
    - 자바 배열은 런타임에 실제 타입을 반드시 알고 있어야 하는(reified, 실체화된) 자료구조다
    - 하지만 제네릭은 런타임에 지워지므로 배열 생성이 불가능
3. `obj instanceof T` 불가능
    - 런타임에 타입 정보가 사라지므로 비교할 실제 타입이 없어서 불가능
4. `List<String>`과 `List<Integer>`의 런타임 타입이 동일
    - JVM 바이트코드는 타입 소거 후 모두 List 형태로만 존재하므로, 런타임에는 동일한 타입으로 간주된다

### 다음 두 선언의 차이를 설명하라 : `List<? extends Number>`, `List<? super Integer>`

`List<? extends Number>`
- 읽을 땐 최소한 Number인것이 보장되므로 안전
- 쓸 땐 Integer, Long 중 어떤 리스트인지 모르므로 null 제외 쓰기 불가
- PECS : `extends`는 Producer (꺼내는 용도)

`List<? super Integer>`
- 쓸 땐 Integer 또는 그 하위 타입을 넣는 것은 안전
- 읽을 땐 리스트에 실제로 어떤 타입이 들어있는지 모르므로 Object로만 읽기 가능
- PECS : `super`는 Consumer (넣는 용도)