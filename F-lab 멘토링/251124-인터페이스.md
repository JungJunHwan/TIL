# 인터페이스

## 인터페이스란?

- 인터페이스는 상태와 행위 중 행위만 존재하는 타입이다
- 메서드에 대한 선언은 있지만 구현은 없다

## 사용하는 핵심 목적 3가지

### 규약 정의

```java
public interface PaymentGateway {
    void pay(int amount);
}
```

이런 인터페이스가 있을 때

```java
public class OrderService {
    private final PaymentGateway paymentGateway;

    public OrderService(PaymentGateway paymentGateway) {
        this.paymentGateway = paymentGateway;
    }

    public void order(int amount) {
        // ... 주문 로직
        paymentGateway.pay(amount);  // 결제 방식은 몰라도 됨
    }
}
```

`OrderService`는 결제 수단이 무엇인지 전혀 몰라도 되고, 결제가 가능한 무언가만 있으면 된다
나중에 아래체럼 구현체를 여러 개 만들 수 있다

```java
public class KakaoPayGateway implements PaymentGateway {
    public void pay(int amount) { /* 카카오페이 로직 */ }
}

public class NaverPayGateway implements PaymentGateway {
    public void pay(int amount) { /* 네이버페이 로직 */ }
}
```

이렇게 구현하면
- 비즈니스 로직은 안 바꾸고, 구현체만 갈아끼우면서 기능 확장이 가능하다

### 다형성을 활용하기 위해

다형성은 같은 타입(인터페이스)으로 묶이지만, 실제 구현은 다르게 동작함을 의미한다

```java
List<Animal> animals = List.of(new Dog(), new Cat(), new Bird());

for (Animal a : animals) {
    a.eat();   // 각각 다른 방식으로 eat()
    a.move();  // 각각 다른 방식으로 move()
}
```

위와 같은 예시가 있을 때
- 변수 타입은 전부 `Animal`
- 실제 객체는 `Dog`, `Cat`, `Bird` 등 서로 다르다
- 인터페이스 덕분에 공통 타입으로 묶어서 처리 가능하다

### 테스트/유지보수/확장성 개선

```java
// 진짜 구현 대신 테스트용 구현체
public class FakePaymentGateway implements PaymentGateway {
    @Override
    public void pay(int amount) {
        System.out.println("테스트이므로 실제 결제 없음. amount=" + amount);
    }
}
```

위와 같은 예시가 있을 때, 테스트 코드에서

```java
@Test
void order_결제호출_테스트() {
    PaymentGateway fake = new FakePaymentGateway();
    OrderService orderService = new OrderService(fake);

    orderService.order(10000);

    // fake에 로그 쌓아두고 assert 하는 식으로 테스트 가능
}
```

- 진짜 PG 연동, 외부 API 호출 없이, 가짜 구현체로 서비스 로직만 검증 가능

## 인터페이스 vs 추상 클래스

|  | 인터페이스 | 추상 클래스 |
| --- | :-- | :-- |
| 상속 구조 | 클래스가 여러 개를 동시에 implements 가능 | 단일 상속만 가능 |
| 목적 | "이런 기능을 제공할 수 있는 타입"을 표현 | "공통 상태 + 공통 로직을 가진 부모 클래스"를 표현 |
| 상태(필드) 보유 | 상수만 가능 (`public static final`) | 인스턴스 필드, 생성자, 일반 메서드 등 다 가질 수 있음 |
| 언제 사용하는지 | 구현체를 다유롭게 바꿀 수 있게 하고, 다중 구현(여러 역할)이 필요할 때 | 기본 구현을 많이 공유해야 하고, 상속 계층이 명확할 때 |

## 한 줄 정리

인터페이스는 구현을 몰라도, 이렇게 쓸 수 있는 타입을 정의하는 규약이다. 이를 사용하는 이유는 구현을 갈아끼우기 쉽고 (확장성), 다형성을 활용해 코드를 깔끔하게 만들고 (유지보수성), 테스트/의존성 주입/디자인 패턴 등과 궁합이 좋기 때문이다 (유연성)

## 꼬리물기

### 자바 8 이후 인터페이스에 default 메서드와 static 메서드를 넣을 수 있게 되었는데, 왜 갑자기 인터페이스가 몸통(구현)을 가질 수 있게 되었을까?

- 인터페이스에 default 메소드를 허용한 이유는, 자바 8에 새로운 기능(Stream, Collaction 유틸 등)을 도입하면서 기존의 수많은 인터페이스에 메소드를 추가해야 했기 때문이다. default 메소드는 기존 구현체들이 깨지지 않도록 하기 위한 해결책이다

### 인터페이스에 default 메소드가 있는데도 추상 클래스가 필요한 이유는 무엇일까?

- 추상 클래스는 상태를 가질 수 있지만, 인터페이스는 상태를 가질 수 없기 때문이다