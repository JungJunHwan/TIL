# 자바 메모리 구조

## Runtime Constant Pool

### 정의

- 각 클래스/인터페이스 마다 클래스 로딩시 Metaspace에 만들어지는 상수 테이블이다
- 클래스 파일의 `constant_pool`을 그대로 올려두는 게 아니라, 심볼(문자열 기반 참조)들을 담아두고, 처음 쓰일 때 실제 대상(필드, 메서드, 클래스 등)으로 해석/결합(resolve/link) 하는 런타임용 구조

### 들어가는 것

- 이곳에 들어가는건 메타데이터/참조이지, 실제 String 객체 자체가 아니다. String 객체는 힙에 있고, 전역 StringTable(힙)에 인턴 풀로 관리된다
- 리터럴 상수
    - int/long/float/double, String 리터럴의 참조 등
- 심볼릭 참조
    - 다른 클래스/인터페이스, 필드, 메서드, 메서드 핸들/타입, 네임&타입 등
- 동적 엔트리
    - `invokedynamic`(Java 7~)
        - 런타임 상수 풀에 있는 부트스트랩 메서드를 통해 CallSite를 만들고, 이후 그 핸들을 캐시해 고성능 다이나믹 바인딩 제공(람다, 동적 언어 구현 등)
    - `CONSTANT_Dynamic`(Java 11~) 같은 부트스트랩 기반 상수/호출지(CallSite)
        - 상수도 부트스트랩으로 지연 계산/캐싱 가능(예: 큰 상수 객체를 최초 사용 때 생성)


### 언제, 어디에 존재하나

- 클래스 로드 시
    - 클래스 파일의 `constant_pool`을 읽어 런타임 상수 풀로 만든다
        - 요건 : Metaspace에 위치
- 초기엔 전부 심볼 상태
    - 사용되는 시점에 해석(resolve)해서 실제 대상의 포인터/레퍼런스로 치환(혹은 캐시)
- 클래스 언로드 시
    - 해당 클래스의 런타임 상수 풀도 함께 소멸

### 간단 예시

```java
class Hello{
    static final int C = 42;
    public static void main(String[] args){
        System.out.println("Hi");
    }
}
```

- `javap -v Hello.class`를 보면 `Constant pool:`에
    - `#1 = Methodref java/io/PrintStream.println:(Ljava/lang/String;)V`
    - `#2 = String "Hi`
    - `#3 = Fieldref java/lang/System.out:Ljava/io/PrintStream;`
- 이처럼 문자열/필드/메서드 참조가 심볼로 들어있고, 실행 중 `ldc #2` -> 힙의 `"Hi"`(StringTable) 참조를 스택에 올려 사용한다

---

## Code Cache (JIT 코드 캐시)

### Code Cache란?

- JVM의 HopSpot JIT 컴파일러가 자주 실행되는 메서드를 기계어로 변환해 저장해두는 전용 메모리 영역
- 자바 바이트코드를 네이티브 코드로 바꾸고, 그 결과를 Code Cache에 캐싱해두는 것

### Code Cache의 세부 구조

- 최근 JVM(특히 HotSpot 8 이후)은 Code Cahce를 여러 구역으로 나눠서 관리한다

| 영역 이름 | 설명 |
| :-- | :-- |
| Non-method Code Heap | JIT가 생성한 보조 코드 (런타임 stub, 인터프리터 코드 등) |
| Profiled Code Heap | C1 컴파일러(빠른, 1차 JIT)가 생성한 코드 |
| Non-profiled Code Heap | C2 컴파일러(고급 최적화용 JIT)가 생성한 코드 |
| (Optional) JVM Stub Heap | 네이티브 호충 관련 작은 코드 조각들 |

### 기본 크기와 설정

| 옵션 | 설명 |
| --- | --- |
| `-XX:ReservedCodeCacheSize` | 전체 Code Cache의 최대 크기 설정 (기본 약 240MB~2400MB) |
| `-XX:InitialCodeCacheSize` | 초기 Code Cache 크기 설정 |
| `-XX:+PrintCodeCache` | Code Cache 상태를 출력 |
| `-XX:+PrintCodeCacheOnCompilation` | JIT 컴파일 시 캐시에 기록되는 로그를 보여줌 |

### Code Cache가 속하는 메모리 영역

- Native Memory
    - OS가 직접 관리하는 영역 (Metaspace, Code Cache 둘 다 여기에 속한다)
- 즉 Code Cache는 네이티브 메모리의 일부로 간주된다

## JIT 최적화의 핵심 구조 - Tiered Compolation

### Tiered Compilation이란?

- 자바는 처음부터 전부 JIT로 돌리지 않는다
- 처음엔 인터프리터로 실행하고, 점점 자주 실행되는 코드를 찾아내서 JIT가 개입하는 단계적 최적화 전략을 사용한다.
- 이 단계를 Tiered Compilation이라고 부른다

### 단계별 구조

| Tier | 실행 형태 | 사용 컴파일러 | 설명 |
| :-- | :-- | :-- | :-- |
| 0단계 | Interpreter | - | 바이트코드를 한 줄씩 해석해서 실행 (가장 느리지만 초기 준비가 필요없다) |
| 1단계 (C1) | Client Compiler (빠른 JIT) | C1 | 자주 실행되는 메서드를 간단히 최적화. 빠른 컴파일 속도, 가벼운 최적화 |
| 2단계 (C1 + Profiling) | Client Compiler + 프로파일링 | C1 | 실해중인 코드의 통계(분기, 루프, 호출, 횟수 등)를 수집 |
| 3단계 (C2 준비) | C2 준비 | C2 | 프로파일링 데이터가 충분히 모이면, 고급 최적화를 위해 준비 |
| 4단계 (C2) | Server Compiler (고급 JIT) | C2 | 실제로 C2 컴파일러가 고급 최적화(루프 전개, 인라이닝, 탈가상화 등)를 수행하여 완전한 네이티브 코드 생성 |

### OST (On-Stack Replacement)

반복문이 매우 긴 메서드가 있을 때
1. 처음엔 Interpreter가 실행
2. 반복문이 수천 번 돌여 Hop loop 판단
3. 반복 도중이라도 JIT가 해당 루프만 컴파일해 Code Cache에 저장
4. 바로 중간부터 JIT 코드로 교체 실행 (OSR)

- 즉, 실행 중에도 JIT 버전으로 핫스왑이 가능하다

---

## Direct Memory (Off-heap)

### Direct Memory란?

- Direct Memory는 JVM Heap 외부(Off-heap)에 존재하는 네이티브 메모리 영역이다
- Heap처럼 GC가 관리하지 않고, OS의 메모리를 직접 할당/해제해서 사용한다
- `ByteBuffer.allocateDirect()` 또는 네이티브 라이브러리(C/C++)를 통해 접근한다

### 왜 Off-heap을 쓰는가?

기본적으로 자바 객체는 Heap에 올라가고 GC가 주기적으로 관리하는데 이 구조에는 몇 가지 성능상의 한계가 있다

1. GC 부하
    - 대용량 데이터 버퍼를 Heap에 올리면 GC가 처리할 객체 수가 많아진다
        - 이는 곧 STW 시간의 증가로 이어진다
2. I/O 복사 비용
    - 네트워크나 파일 I/O는 커널 버퍼(네이티브 메모리)와 JVM Heap 사이를 오가야 한다
        - 이 때문에 데이터를 주고받을 때 2번 복사가 발생한다

- Direct Memory는 커널 버퍼와 거의 바로 연결되어 있어서, 복사 횟수를 줄이고 I/O 속도를 높일 수 있다

### Direct Memory 사용 예시

```java
import java.nio.ByteBuffer;

public class DirectMemoryExample {
    public static void main(String[] args) {
        // 일반 Heap 메모리 버퍼
        ByteBuffer heapBuffer = ByteBuffer.allocate(1024);

        // Direct Memory (Off-heap) 버퍼
        ByteBuffer directBuffer = ByteBuffer.allocateDirect(1024);

        System.out.println(heapBuffer.isDirect());   // false
        System.out.println(directBuffer.isDirect()); // true
    }
}
```

- `allocateDirect()`를 사용하면 JVM이 OS에 직접 메모리를 요청해 GC 관리 밖의 공간을 얻는다

### 주의점

- GC가 관리하지 않기 때문에 명시적 해제를 하지 않으면 OS 메모리 누수가 생긴다
- 실제로 `ByteBuffer.allocateDirect()`는 내부적으로 sun.misc.Cleaner를 등록해두지만, GC 타이밍에 따라 해제가 늦어질 수 있다
- 따라서, 대규모 버퍼를 자주 생성/폐기하는 구조에서는 직접 해제하거나 버퍼 풀(Buffer Pool)을 사용해야 한다

### JVM 옵션

- `-XX:MaxDirectMemorySize`
    - 이걸 지정하지 않으면 기본값은 -Xmx (Heap 최대 크기)와 같다

---

## String Intern Pool (= String Pool / StringTable)

### 정의

- 같은 내용의 문자열을 하나만 유지하고 모든 참조가 그 하나를 공유하게 만들어 메모리와 비교 비용을 줄이는 구조
- 문자열 리터럴과 `intern()`으로 등록한 문자열을 보관하는 해시 테이블
- 자바 7이후로는 Heap에 있는 StringTable에 저장된다
- 엔트리는 약한 참조로 관리되어, 그 문자열을 다른 곳에서 더 이상 강하게 참조하지 않으면 GC가 회수 가능하다

### 저장 방식

- 문자열 리터럴

```java
String a = "hi";      // 컴파일 시 상수 폴딩 → 풀에 등록
String b = "hi";      // 같은 엔트리 재사용
a == b  // true

```

- 런타임 생성 문자열

```java
String x = new String("hi"); // 항상 새 객체 (풀 X)
x == "hi" // false

String y = ("he" + "llo");   // 둘 다 상수 → 컴파일 타임에 "hello"로 폴딩됨(풀 등록)
String v = (someVar + "lo"); // 변수 포함 → 런타임 새 객체(풀 X)

```

- `intern()` 호출

```java
String s1 = new String("abc");
String s2 = s1.intern();      // 풀에 "abc"가 없으면 등록 후 그 “풀 객체” 반환
s2 == "abc" // true

```