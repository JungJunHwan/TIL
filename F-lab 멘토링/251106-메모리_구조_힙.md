# 자바 메모리 구조

## 힙(Heap) 영역 - 쉬운 설명

### 힙이란?

- 힙은 자바 프로그램에서 모든 객체가 실제로 저장되는 공간이다
- 자바에서는 다음과 같이 new를 사용해서 객체가 만들어지는데
- ```java
     Person p = new Person;
    ```
- 이 순간 p는 변수(주소 저장용)이고, 실제 Person 객체 데이터는 힙 메모리에 올라간다
- 즉,
- > 객체의 실제 내용이 담긴 창고 = 힙

### 힙이 필요한 이유

- 자바에서는 함수가 끝나도 객체가 남아 있어야 한다
- ```java
    Person makePerson(){
        Person p = new Person();
        return p;
    }
    ```
- 여기서 함수는 끝났지만 p는 여전히 다른 코드에서 사용할 수 있어야 한다
- 하지만 스택은 함수가 끝나면 바로 사라지니, 이런 지속되는 데이터를 저장하려면 별도 공간이 필요하며 그게 바로 힙이다

### 힙의 역할

|구분|설명|
|:-:|:--|
| 저장 대상 | new 로 생성된 객체, 배열 등 |
|관리 주체 | JVM (개발자가 직접 해체하지 않는다) |
| 수명 | GC가 정리할 때까지 |
| 공유 여부 | 모든 스레드가 함께 사용 (공유 메모리) |

### 힙 내부 구조 (HopSpot 기준)

- 힙은 크게 "세대(Generation)" 개념으로 나뉘어 있다
    - 객체의 생명주기를 효율적으로 관리하기 위한 구조이다

```
    - Heep
        - Young Generation (새 겍체)
            - Eden Space
            - Survivor Space (S0, S1)
        - Old Generation
```

### 세대별 구조 설명

#### Young Generation - 새로 태어난 객체들

- 대부분의 객체가 처음엔 여기에 생성된다
- 구조
    - Eden
        - 새로 만들어진 객체들이 일단 여기에 저장된다
    - Survivor 0 / Survivor 1
        - 살아남은 객체들이 잠시 머무르는 공간

#### Young GC (Minor GC)

- 자바는 주기적으로 Gabage Collector가 와서 청소한다
    1. Eden에서 더 이상 참조되지 않는 객체는 삭제된다
    2. 살아남은 객체만 Survivor로 복사
    3. Survivor에서도 계속 살아남는 객체는 나이가 쌓여서 Old Generation으로 승격된다
- 이 과정을 "Young GC" 또는 "Minor GC"라고 부른다

#### Old Generation - 오래 사는 객체들

- 여러번 GC에서 살아남은 객체가 여기에 저장된다
- 크기가 크고, GC 빈도는 낮지만 한번 청소할 때 시간이 오래 걸린다
- 이 영역의 청소는 "Major GC" 또는 "Full GC" 라고 부른다

### 객체의 생애 주기

| 단계 | 위치 | 설명 |
| :-- | :-- | :-- |
| 객체 생성 | Eden | new로 만든 객체|
| 첫 GC | Eden -> Survivor | 살아남은 객체만 복사 |
| 여러 번 생존 | Survivor -> Old | 일정 횟수 이상 살아남으면 승격 |
| 더 이상 참조 없음 | GC 대상 | 참조가 사라지면 청소됨 |

---
---

## 힙(Heap) 영역

### 정의

- 힙은 JVM 런타임 데이터 영역 중 모든 인스턴스와 배열이 동적 할당 되는 메모리 영역이다
- 즉, 
> 자바의 객체는 모두 힙에 저장되고, 이 영역은 GC에 의해 자동으로 관리된다 

### 생성 시점 & 공유 범위

- 생성 시점 : JVM이 시작될 때 힙이 생성된다
- 공유 범위 : JVM 내의 모든 스레드가 힙을 공유한다
    - 즉, 여러 스레드가 같은 객체를 참조할 수 있다
- Thread-safety는 보장되지 않으므로, 객체 공유 시 동기화(Synchronization)가 필요하다

### 구조적 세분화

- HotSpot VM에서는 힙을 세대 단위로 나누며, 이를 Generational Garbage Collection이라고 부른다

```
    - Heap
        - Young Generation
            - Eden Space
            - Survivor Spaces (S0, S1)
        - Old Generation (Tenured)
```

### 세대별 역할

#### Young Generation
- 역할
    - 새로 생성된 객체의 대부분이 위치
- 구성
    - Eden Space
        - 새로 생성된 객체가 최초로 할당되는 연역
    - Survivor 0/1
        - Young GC 후 살아남은 객체가 복사되어 이동되는 영역
        - Survivor 영역에는 특별한 규칙이 있는데, S0 또는 S1 둘 중 하나는 꼭 비어 있어야 하는 것이다
            - 그 이유는 GC가 복사 방식으로 살아남은 객체를 이동시키기 때문이다
            - 살아있는 객체만 복사해서 다른 곳으로 옮기고, 나머지는 한꺼번에 버린다
- GC 과정 (Minor GC)
    - Eden에서 살아남은 객체를 Survivor로 복사
    - Survivor 간에는 copying collector 방식으로 교차 복사
    - 객체마다 age가 증가하며 일정 threshold(MaxTenuringThreshold)를 넘으면 Old Generation으로 promotion된다
- 대표 알고리즘
    - Scavenge GC (copying algorithm)
    - TLAB (Thread-Local Allocation Buffer) 최적화 사용
        - 각 스레드가 Eden의 일부를 분할해 락 없이 빠르게 객체 할당

#### Old Generation

- 역할
    - 여러번의 Minor GC를 거쳐 살아남은 장수 객체(long-lived objects)가 위치
- GC 과정 (Major / Full GC)
    - Old 영역은 MSC(Mark-Sweep-Compact) 또는 Region 기반(G1) 알고리즘으로 수집된다
    - 단순 복사로 처리하기엔 크기가 커서, 보통 Mark -> Sweep -> Compact 순서로 처리한다
    - GC 시간(Pause time)이 상대적으로 길다
- 대표 알고리즘
    - Serial GC
        - MSC
    - Parallel GC
        - 멀티스레드 기반 Mark-Compact
    - G1 GC
        - Region 단위 Mark-Region-Relocate (기본 GC)
    - ZGC / Shenandoah
        - Concurrent(동시) GC 기반 저지연 구조

### 객체의 Life Cycle

| 단계 | 위치 | 설명 |
| :-- | :-- | :-- |
| 객체 생성 | Eden | 모든 객체는 Eden에서 생성됨 |
| Minor GC 후 생존 | Survivor | 복사 후 age 증가 |
| 여러 번 생존 | Old Gen | 일정 횟수 이상 생존 시 promotion |
| 참조 해제 | GC 대상 | 참조가 끊어지면 수거됨 |

### 주요 파라미터 (HopSpot Options)
| 옵션 | 의미 |
| --- | --- |
| `-Xms<size>` | Heap 초기 크기 |
| `-Xmx<size>` | Heap 최대 크기 |
| `-XX:NewSize=<size>` | Young Generation 초기 크기 |
| `-XX:MaxNewSize=<size>` | Young Generation 최대 크기 |
| `-XX:NewRatio=<n>` | Old:Young 비율 설정 (예: 2 → Old:Young = 2:1) |
| `-XX:SurvivorRatio=<n>` | Eden:Survivor 비율 (예: 8 → 8:1:1) |
| `-XX:MaxTenuringThreshold=<n>` | Survivor에서 Old로 승격되기 전 생존 횟수 |


### 메모리 관리 알고리즘 개요

- Minor GC (Young Collection)
    - 수집 대상
        - Young Generation
    - 알고리즘
        - Copying Collector
    - 특징
        - 빠르고 빈번함
        - STW(Stop-The-World) 발생
- Major GC (Old Collection)
    - 수집 대상
        - Old Generation
    - 알고리즘
        - MSC / G1 / ZGC 등
    - 특징
        - 처리 시간 길지만 빈도 낮음
- Full GC
    - 수집 대상
        - Heap 전체 + Metaspace 포함
    - 트리거
        - System.gc(), Old GC 실패, Metaspace 부족 등
    - 특징
        - 가장 비용이 크며 STW 시간이 길다

### Stop The World (STW)

- JVM이 모든 애플리케이션 스레드의 실행을 완전히 멈추고, GC나 JIT 등 JVM 내부 작업만 수행하는 상태
- GC는 객체 참조 관계를 따라가며 어떤 객체가 살아있고, 어떤 객체를 버려도 되는지를 분석한다
- 이때 프로그램이 돌아가는 중이라면 객체 참조가 변할 수 있기 때문에 safe point를 만들어서 모든 스레드를 중단시킨 후 메모리를 정리한다
- 아무때나 멈추는건 아니고 JVM이 코드 중간중간에 safe point를 삽입해두고, STW를 발생할 때 각 스레드는 safe point에 도달할 때까지 실행하고 거기서 멈춘다
- 즉, STW는 모든 스레드가 safe point에 도달해서 안전하게 정지된 상태이다

### STW가 일어나는 주요 상황

| 구분 | 설명 |
| --- | --- |
| **Minor GC** | Young Generation 수집 시 잠깐 STW 발생 |
| **Major / Full GC** | Old Generation 수집 시 상대적으로 긴 STW |
| **JIT Compilation** | 메서드를 컴파일할 때도 STW 구간이 짧게 발생 |
| **Class Loading** | 새 클래스를 로드하고 초기화할 때 |
| **Deoptimization** | JIT 최적화가 깨져 다시 인터프리터로 돌아갈 때 |
| **Thread Dump, Heap Dump** | 사람이 수동으로 `jstack`, `jmap` 등을 찍을 때도 STW 발생 |

### STW 최소화를 위한 접근들

| 방법 | 설명 |
| --- | --- |
| **G1 GC** | 영역 기반 GC로 pause를 짧게 나눔 |
| **ZGC / Shenandoah** | 대부분의 GC 작업을 애플리케이션 스레드와 동시에 수행 |
| **Heap 크기 튜닝** | 지나치게 작은 힙은 잦은 GC로 STW 빈도 증가 |
| **객체 재사용** | 단명 객체 생성 억제로 Young GC 빈도 감소 |
| **오프힙 메모리 사용** | GC 관리 밖에 있는 DirectBuffer 등 활용 |

### 내부 최적화 개념

| 용어 | 설명 |
| --- | --- |
| TLAB (Thread Local Allocation Buffer) | 스레드마다 Eden 일부를 분리하여 객체 할당 경쟁을 줄임 |
| Promotion | Survivor 객체가 Old Generation으로 승격되는 과정 |
| Card Table / Remembered Set** | 세대 간 참조를 추적하기 위한 데이터 구조 |
| Write Barrier | 객체 참조 변경 시 GC 추적 정보 갱신용 바이트코드 삽입 |
| Compressed Oops | 64비트 JVM에서 32비트 참조 포인터로 메모리 절약 |
| Humongous Objects | (G1 기준) 매우 큰 객체를 위한 별도 리전 처리 방식 |
