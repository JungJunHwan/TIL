# 자바 메모리 구조

## PC Register (Program Counter Register)

### PC Register란?

- 현재 실행 중인 명령어의 주소(위치)를 저장하는 공간
- JVM은 바이트코드라는 명령어 단위로 프로그램을 수행한다
- 이때 어떤 명령어를 실행 중인지, 다음에 어떤 명령어를 실행해야 하는지를 알아야 한다
- 그 정보를 저장하는 게 PC Register다
- 지금 이 스레드가 자바 바이트코드 어디를 실행 중인가를 가리키는 스레드 전용(thread-private) 지시자

### 스레드와의 관계

- 자바는 멀티스레드를 지원하는데, 이때 각 스레드는 독립적인 PC Register를 가진다
- 각 스레드가 서로 다른 명령어를 실행 중일 수 있기 때문이다

### PC Register가 담는 것

- 메서드 + 바이트코드 인덱스(BCI)
    - 어떤 자바 메서드의 몇 변째 BCI 인가를 나타내는 쌍
    - 예) `(java/lang/String::concat, bci=42)`
- 네이티브 실행 시
    - 스레드가 native 메서드(JNI) 안에 있을 땐 자바 바이트코드 위치의 의미가 업어서, 구현에 따라 미정(undefined) 또는 특별한 표식 상태가 될 수 있다

### 업데이트 방식

- 연속 실행
    - 대부분의 바이트코드를 실행하면, 현재 바이트코드 길이만큼 BCI가 증가해 다음 명령으로 이동한다
- 분기/점프
    - `if_*`, `goto`, `tableswitch`, `lookupswitch` 같은 분기 명령은 BCI를 증가가 아니라 점프(target BCI로 치환)한다
- 호출/리턴
    - `invoke*`로 다른 메서드로 들어가면 새 스택 프레임이 생기고, 그 프레임의 시작 BCI(보통 0)로 PC가 이동한다
    - `return` 시에는 호출자 프레임의 다음 BCI로 돌아간다
- 예외
    - 예외가 발생하면 VM이 예외 테이블을 찾아 핸들러의 BCI로 PC를 재설정하거나, 없으면 프레임을 언와인드하며 상위로 전파한다

### 스레드와 PC Register의 관계

- 스레드당 1개
    - 각 스레드는 자기 실행 위치를 스스로 관리해야 하므로 PC Register를 따로 가진다
- Safe point & STW
    - GC 같은 이유로 모든 스레드를 멈춰야 할 때, VM은 스레드들이 safe point로 도달하길 기다린다
    - 이 때 각 스레드의 PC가 멈춤의 근거가 된다

### 인터프리터 vs JIT(컴파일된 코드)에서의 PC

- 인터프리터 모드
    - PC는 말 그대로 현재 BCI를 직접 가리킨다
- JIT 컴파일된 코드
    - 실제 실행은 CPU의 기계어 PC 위에서 돌아가지만, HotSpot은 현재 기계어 PC를 역매핑하여 어떤 자바 프레임/BCI인지를 알아낼 수 있게 해둔다

### 스택 프레임과의 연결

- 각 스택 프레임은 현재 메서드, 지역변수 배열, 오퍼랜드 스택, 현재 BCI를 암묵적으로(또는 메타데이터로) 가진다고 보면 된다
- 스택 트레이스를 찍을 때, VM은 프레임들의 BCI를 소스 라인으로 매핑해 파일:라인을 만들어낸다
- PC가 없으면 정확한 스택 트래이스/디버깅이 불가능하다

### 예외/동기화와 PC

- 예외 처리
    - VM은 예외가 발생한 현재 PC(BCI)를 기준으로 예외 테이블을 조회해 핸들러로 점프한다
- synchronized/모니터
    - `monitorenter/monitorexit`도 바이트코드라서, 락 획득/해제를 실패하거나 예외가 날 때 어느 위치에서 실패했는지 PC가 알려준다

### GC와 PC

- 루트 스캔 & 오브젝트 매핑
    - GC는 각 프레임의 BCI/메타데이터를 통해 이 시점에 레지스터/스택 어디에 참조가 있는가를 알아내서 정확한 GC를 수행한다