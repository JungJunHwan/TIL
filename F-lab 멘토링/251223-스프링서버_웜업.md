# 스프링 서버 웜업

## JVM 및 JIT 컴파일러의 최적화 지연

Java 애플리케이션은 JVM의 동작 방식 때문에 실행 즉시 최고의 성능을 내지 못한다

- JIT 컴파일 최적화
    - JVM은 처음엔 바이트코드를 해석하며 실행하다가, 반복되는 코드(Hot Spot)를 발견하면 이를 네이티브 기계어로 컴파일하여 캐싱한다
    - 이 과정이 완료되기 전까지는 실행 속도가 상대적으로 느리다
- 코드 캐싱
    - 웜업을 통해 주요 비즈니스 로직을 미리 실행시켜두면, JIT 컴파일러가 최적화된 기계어를 생성하여 Code Cache에 담아둘 수 있다

## 스프링 프레임워크의 지연 초기화 (Lazy Loading)

스프링은 기본적으로 싱글톤 빈을 컨텍스트 로딩 시점에 생성하지만, 모든 것이 준비되는 것은 아니다

- Spring Bean 및 프록시 초기화
    - 일부 빈이나 AOP 프록시 객체, Reflection 기반의 작업들은 실제 호출되는 시점에 처음으로 초기화되거나 경로를 탐색하는 경우가 많다
- Lazy 로딩 지연
    - 설정에 따라 지연 로딩되도록 구성된 빈들은 첫 요청이 들어올 때 비로소 생성되므로 첫 사용자에게 응답 지연을 유발한다

### 컨텍스트 로딩 (Context Loading)

컨텍스트 로딩 시 일어나는 일

- 스프링은 개발자가 직접 객체를 생성(`new`)를 하지 않고 스프링에게 맡기는 IoC 방식을 사용한다
- 서버가 켜질 때 다음의 작업이 순차적으로 진행된다
    1. 설정 읽기
        - `SpringBootApplication`, `Configuration` 등을 스캔해 어떤 설정이 필요한지 파악한다
    2. Bean 정의 등록
        - 어떤 클래스를 객체를 만들고 관리해야 할지 목록을 만든다
    3. 객체 생성
        - 정의된 목록을 바탕으로 실제 자바 객체를 생성한다
    4. 의존성 주입
        - 생성된 객체들끼리 서로 필요한 부품을 연결해준다
    5. 초기화 콜백
        - 객체 생성과 연결이 끝나면 `@PostConstruct` 같은 초기화 메소드를 실행하여 최종 준비를 마친다

기본적으로 스프링의 빈은 싱글톤이며, 컨텍스트 로딩 시점에 즉시 생성되나, 다음의 경우에는 실제 호출 시점까지 생성이 미뤄진다

1. `@Lazy` 어노테이션 사용
    - 특정 빈에 `@Lazy`를 붙이면, 컨텍스트 로딩 시점에 빈 정의는 등록되지만 실제 객체 생성은 그 빈이 처음 사용되는 시점까지 지연된다
    - 메모리 절약이나 순환 참조 해결, 혹은 거의 사용되지 않는 무거운 객체이기 때문
2. 스코프가 싱글톤이 아닌 경우
    - Prototype 스코프
        - 요청할 때마다 매번 새로운 객체를 만들어야 하므로, 컨텍스트 로딩 시점이 아니라 `getBean()`이 호출될 때 생성된다
    - Request / Session 스코프
        - 웹 요청이 들어오거나 세션이 생성되는 시점에 만들어진다
3. Proxy 메커니즘
    - `@Transactional`이나 AOP가 적용된 빈은 컨텍스트 로딩 시점에 진짜 객체 대신 가짜 프록시 객체가 먼저 주입될 수 있다
    - 사용자가 메소드를 호출하면, 그제서야 프록시가 내부적으로 진짜 객체를 찾아 초기화하고 로직을 수행한다

#### 가짜 프록시 객체를 먼저 주입하는 이유 (BeanPostProcessor)

1. 비즈니스 로직에만 집중하게 하기 위해서 (AOP)
    - 핵심 로직과 공통 작업을 분리하기 위해서이다
        - 진짜 객체 : 핵심 로직
        - 가짜 프록시 : 공통 작업
    - 만약 진짜 객체를 그대로 주입받는다면, 모든 메소드마다 `try-catch`와 트랜잭션 코드를 직접 짜야하지만, 스프링은 프록시가 이런 일들을 다 처리하게 만든다
2. 순환 참조
    - 두 개의 빈이 서로를 필요로 하는 순환 참조 상황에서 프록시는 해결책이다
        - 상황 : A 객체를 만드려면 B가 필요하고, B 객체를 만드려면 A가 필요하다
        - 해결 : 스프링은 일단 가짜 객체(Proxy) A를 만들어서 B에게 준다
            1. B는 일단 가짜 A를 받았으니 생성이 완료된다
            2. 그 후 진짜 A가 만들어지면, 가짜 A와 진짜 A를 내부적으로 연결한다
3. 필요할 때만 생성하기 위해서 (지연 로딩)
    - 성능이나 메모리 효율을 위해 객체 생성을 최대한 미루고 싶을 때 프록시를 사용한다
        - 상황 : 어떤 객체는 생성 비용이 너무 큰데, 실제로 사용될 확룰은 낮다
        - 작동 방식 : 스프링은 일단 가벼운 가짜 프록시를 주입해두고 코드에서 실제로 객체를 호출하는 순간, 프록시가 내부적으로 진짜 객체를 생성한다

<br>

이 모든 과정은 스프링의 BeanPostProcessor라는 장치에 의해 일어난다

- 빈의 일생과 BPP의 개입 시점
    1. 객체 생성
    2. 의존성 주입
    3. 초기화 전 처리 : BPP가 개입하여 초기화 메소드가 실행되기 전에 역할 수행
    4. 초기화
    5. 초기화 후 처리 : BPP가 개입하여 초기화 메소드가 실행된 후에 역할 수행. 대부분의 프록시는 이 시점에 만들어진다
- 주요 역할
    - 가짜 프록시 객체로 바꿔치기
        - 원래 만든 `OrderService` 객체 대신, 트랜잭션 기능이 추가된 `OrderServiceProxy` 객체를 컨테이너에 대신 넣는다
        - 우리가 주입받아 쓰는건 이때 BPP가 바꿔치기한 가짜이다
    - 어노테이션 해석 및 처리
        - 클래스에 붙이는 어노테이션들을 BPP가 확인해 어노테이션의 의미에 맞게 객체에 기능을 입히는 역할 수행
    - 빈 설정 강제 수정
        - 특정 조건을 만족하는 빈들의 설정을 개발자가 모르게 일괄적으로 바꾸고 싶을 때 사용

<br>

- 웜업과 BPP의 관계
    - BPP의 작업량
        - 스프링 부트는 수백 개의 빈을 관리하고, 각 빈마다 수십 개의 BPP가 적용된다
    - 지연되는 판단
        - 어떤 가공(프록시 생성)은 서버가 뜰 때 완벽히 끝나지 않고, 해당 빈이 실제 호출될 때 마지막 연결 작업을 수행하기도 한다
    - 결과
        - 이 가공 작업과 바꿔치기 로직이 복잡할수록 서버 초기 구동 속도가 느려지고, 첫 번째 요청에서 길 찾는 시간이 필요하게 된다
        - 그래서 웜업을 통해 이 복잡한 로직들이 한 번씩 다 돌아가게 만드는 것이다

### 리플렉션(Reflection)

리플렉션은 자바가 기본적으로 제공하는 기술로, 구체적인 클래스 타입을 몰라도 그 클래스의 정보를 들여다보고 조작할 수 있는 거울과 같은 기능이다

1. 리플렉션으로 하는 대표적인 작업
    - 어노테이션 읽기
        - 클래스 위에 어떤 어노테이션이 붙었는지 런타임에 확인하고 기능을 부여
    - private 필드에 값 넣기
        - `@AutoWired`를 붙이면, 스프링은 리플렉션을 사용해 `private`로 선언된 변수에 강제로 객체를 주입한다
    - 프록시에서 진짜 객체 호출하기
        - 가짜 프록시 객체가 사용자의 요청을 받으면, 리플렉션을 사용해 진짜 객체를 실행하라고 명령을 내림
2. 비유 : 매뉴얼 보고 동작하기
    - 직접 호출 (컴파일 시점)
        - 숙련된 요리사가 레시피를 다 외워서 바로 요리하는 것 (매우 빠름)
    - 리플렉션 (런타임 시점)
        - 초보 요리사가 레시피를 하나씩 확인하며 요리하는 것 (매우 느림)

<br>

- 리플렉션과 웜업의 관련
    1. 조회 비용 (Lookup Cost)
        - 리플렉션은 실행 중에 이 클래스에 어떤 메소드가 있는지 계속 검색하고 보안 체크를 수행해야 한다
        - 이 과정이 일반적인 메소드 호출보다 훨씬 무겁다
    2. 메타데이터 캐싱
        - 자바와 스프링은 리플렉션 성능을 높이기 위해, 한 번 찾아낸 정보(메타데이터)를 캐싱한다
    3. 최초의 지연
        - 맨 처음 호출될 때는 캐시가 비어있기 때문에 클래스 정보를 일일이 다 뒤져야 하느라 응답 시간이 튀게 된다

## 커넥션 풀(Connection Pool) 준비 부족

데이터베이스나 외부 메시지 브로커와의 연결은 비용이 매우 큰 작업이다

- Lazy Init 기반의 풀
    - HikariCP(DB), Redis, Kafka 등의 커넥션 풀은 설정에 따라 애플리케이션 시작 시점에 모든 연결을 생성하지 않고, 실제 사용 시점에 연결을 맺기도 한다
- 연결 비용
    - 첫 요청 시점에 TCP 핸드셰이크가 일어나고 물리적인 연결이 맺어지면 상당한 레이턴시가 발생한다
    - 웜업을 통해 이 커넥션들을 미리 활성화 해야한다

## 캐시 및 룰 엔진 데이터 로딩

데이터를 빠르게 조회하기 위한 캐시 시스템도 처음에는 비어있다 (Code Cache)

- 초기 상태의 빈 캐시
    - Redis, Ehcache, 로컬 캐시 등은 서버 시작 직후 비어있어 모든 데이터를 DB에서 읽어와야 한다
- 룰 엔진(Rule Engine)
    - 복잡한 비즈니스 로직을 처리하는 룰 엔진은 초기 구동 시 규칙을 파싱하고 메모리에 로딩하는 과정에서 많은 리소스를 소모한다

## SQL 및 데이터 액세스 기술 최적화

 SQL을 실행하기 위한 준비 과정도 시간이 필요하다

 - SQL 빌드 및 메타데이터 지연
    - JPA(Hibernate), QueryDSL, MyBatis 등은 첫 쿼리 실행 시 엔티티 메타데이터를 분석하고, JPQL을 SQL로 변환하거나 SQL문을 빌드하는 과정을 거친다
    - 이 과정이 첫 실행 시점에 몰리면 성능이 저하된다

## 외부 API 및 네트워크 인프라 대응

자체 서버뿐만 아니라 외부 시스템과의 통신 환경도 예열이 필요하다

- DNS 리졸빙 및 TLS 핸드셰이크
    - 외부 써드파티 API를 처음 호출할 때 도메인 주소를 IP로 바꾸는 DNS lookup과 보안 연결을 위한 TLS 핸드셰이크가 발생하여 지연이 생긴다
- ELB 및 K8S Readiness 체크 안정성
    - K8S 환경에서 서버가 떴다고 판단하는 Readiness Probe가 통과되어 트래픽이 유입되더라도, 실제 애플리케이션 내부가 준비되지 않으면 에러가 발생할 수 있다