# HTTPS 핸드셰이크 과정

## 1. 랜덤키 + 암호화 방식 서버에 전달 (Client Hello)

클라이언트가 서버에 연결을 시도하며 인사를 건네는 과정

- 브라우저는 서버에 Client Hello 메시지를 보낸다
- 이때 자신이 지원 가능한 암호화 방식(Cipher Suite) 목록과 클라이언트 측에서 생성한 난수를 함께 전달한다
- 이 난수는 나중에 대칭키를 만들 때 사용된다

<br>

- Client Hello는 TLS 프로토콜 표준 문서(RFC)에 명시된 실제 기술 용어다

## 2. 암호화 방식 선택 + 랜덤키 + 인증서 전달 (Server Hello)

클라이언트의 인사를 받은 서버가 응답하는 단계

- 서버는 클라이언트가 보낸 암호화 방식 중 하나를 선택하고, 서버 측에서 생성한 난수와 함께 자신의 SSL/TLS 인증서를 클라이언트에게 보낸다
- 이 인증서 안에는 서버의 공개키(Public Key)가 포함되어 있다

### SSL/TLS

- SSL (Secure Sockets Layer)
    - 1990년대 초 넷스케이프 사에서 처음 만들었으나, 보안 취약점이 발견되며 지금은 사용되지 않는 과거의 기술
- TLS (Transport Layer Security)
    - SSL의 문제점을 보완해서 나온 후속 표준 기술
        - 오늘날 SSL 인증서라고 부르는 것들은 기술적으로 모두 TLS를 의미한다 (마치 포스트잇이 고유 명사처럼 쓰이는 것과 비슷함)
- SSL/TLS의 핵심 3가지 역할
    - 암호화 (Confidentiality - 기밀성)
        - 데이터를 가로채더라도 내용을 알 수 없게 만든다
            - 핸드셰이크 과정을 통해 생성된 대칭키를 사용한다
    - 인증 (Authentication - 인증)
        - 내가 접속한 사이트가 진짜인지 확인한다
            - 제3의 공인 기관인 CA가 발행한 인증서를 사용한다
    - 무결성 (Integrity - 무결성)
        - 데이터가 전송 중에 변조되지 않았음을 보장한다
            - 메시지 인증 코드(MAC)라는 디지털 서명 기술을 사용

## 3. 브라우저에 저장된 CA 기관을 사용해 인증서 검증

서버가 보낸 인증서가 믿을만한지 확인하는 단계

- 브라우저(또는 OS)에는 신뢰할 수 있는 CA(인증 기관, Certificate Authority)들의 리스트와 그들의 공개키가 이미 저장되어 있다
- 브라우저는 이 CA의 공개키를 이용해 서버가 보낸 인증서의 디지털 서명을 복호화하여, 해당 인증서가 가짜가 아닌지, 유효기간이 지나지 않았는지 확인한다
- 신뢰가 확인되면 서버의 공개키를 획득한다

### CA (Certificate Authority, 인증 기관)

CA가 신뢰를 보장하는 원리 : 계층적 신뢰 구조

- 디지털 서명 (보증서 낙인 찍기)
    - 서버가 CA에 인증을 요청하면, CA는 서버의 정보를 확인한 후 자신의 개인키로 해당 정보를 암호화하는데 이것이 디지털 서명이다
    - 모든 브라우저에는 CA의 공개키가 이미 들어있다. 브라우저는 이 공개키로 서버가 가져온 인증서를 복호화해본다
    - 만약 성공적으로 풀린다면 CA가 보증한 게 맞음을 확신한다
- 신뢰의 사슬 (Chain of Trust)
    - 세상에는 너무 많은 사이트가 있어서 하나의 CA가 모두 관리할 수 없다 -> 계층 구조를 가진다
        1. ROOT CA : 가장 최상위 기관으로 이들의 인증서는 브라우저/OS 제조사가 무조건 믿는다고 미리 등록해둔다
        2. Intermediate CA : Root CA로부터 권한을 위임받아 실제 인증서를 발급한다
        3. End-Entity : 우리가 접속하는 실제 서버

<br>

인증서의 종류

- CA는 얼마나 꼼꼼하게 검사하느냐에 따라 세 가지 등급의 인증서를 발급한다
    - DV (Domain Validation)
        - 도메인 소유권만 확인 (이메일/DNS 확인)
        - 가장 빠르고 저렴함
        - 용도 : 개인 블로그, 소규모 사이트
    - OV (Organization Validation)
        - 도메인뿐만 아니라 실제 기업/단체가 실존하는지 서류 심사
        - 용도 : 기업 웹사이트, 서비스 페이지
    - EV (Extended Validation)
        - 매우 엄격한 심사
        - 기업의 물리적 주소, 전화 확인 등
        - 용도 : 금융권, 대형 이커머스

## 4. 인증서로 키를 암호화해서 전달 (Pre-Master Secret 생성)

데이터를 암호화할 진짜 키를 만들기 위한 준비

- 클라이언트는 다시 한번 새로운 임의의 난수인 Pre-Master Secret을 생성
- 이전 단계에서 얻은 서버의 공개키로 이 값을 암호화하여 서버에 전송
- 공개키로 암호화 했기 때문에 오직 서버의 개인키로만 풀 수 있어 중간에 탈취당해도 안전

## 5. 개인키로 복호화

서버가 클라이언트가 보낸 암호화된 키 정보를 확인하는 단계

- 서버는 자신이 안전하게 보관하고 있는 개인키(Private Key)를 사용하여 클라이언트가 보낸 메시지를 복호화한다
- 이를 통해 서버와 클라이언트는 동일한 Pre-Master Secret 값을 공유하게 된다

## 6. 서버/클라이언트는 난수 Pre-Master Secret을 조합해 대칭키 생성

최종적으로 통신에 사용할 세션 키를 완성하는 단계

- 지금까지 주고받은 세 가지 값(클라이언트 난수 + 서버 난수 + Pre-Master Secret)을 조합하여 최종적으로 데이터를 암호화할 대칭키(Session Key)를 생성
- 공개키 방식(비대칭키)은 계산 복잡도가 높아 속도가 느리기 때문에, 실제 데이터를 주고받을 때는 속도가 빠른 대칭키 방식을 사용한다