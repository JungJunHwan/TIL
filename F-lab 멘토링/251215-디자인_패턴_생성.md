# GoF (Gang of Four) 디자인 패턴

## 생성

### 싱글톤 패턴 (Singleton Pattern)

- 정의
    - 특정 클래스의 인스턴스가 오직 하나만 생성되도록 보장하고, 어디서든 이 인스턴스에 접근할 수 있도록 하는 패턴
    - **스프링 프레임워크**에서는 컨테이너가 빈(Bean)을 생성하고 관리하는 **싱글톤 레지스트리** 역할을 수행하여, 개발자가 직접 싱글톤을 구현할 필요가 없습니다.

<br>

실무 적용 예시 (Spring Framework)
- **동작 원리**: `@Service`, `@Component` 등의 어노테이션을 사용하면 스프링 컨테이너가 시작될 때 객체를 딱 하나만 생성하여 관리합니다.
- **주의 사항**: 싱글톤 객체는 멀티스레드 환경에서 공유되므로, **멤버 변수에 상태(State)를 저장하지 않도록(Stateless)** 설계해야 합니다.

```java
import org.springframework.stereotype.Service;
import java.util.concurrent.atomic.AtomicInteger;

@Service
public class OrderService {

    // [중요] 싱글톤 빈의 멤버 변수는 모든 스레드가 공유합니다.
    // 따라서 상태를 공유해야 한다면 반드시 Thread-Safe한 객체(Atomic 등)를 사용해야 합니다.
    // 일반적인 int, List 등을 멤버 변수로 두고 수정하면 심각한 동시성 이슈가 발생합니다.
    private AtomicInteger totalOrderCount = new AtomicInteger(0);

    public void createOrder(String userId, int amount) {
        // 1. 비즈니스 로직에 필요한 데이터는 지역 변수(Local Variable)로 받아 처리합니다.
        // 지역 변수는 스레드마다 별도의 스택 메모리를 사용하므로 안전합니다.
        int discountedAmount = calculateDiscount(amount);

        System.out.println("사용자 " + userId + " 주문 처리: " + discountedAmount + "원");
        
        // 2. 공유 변수 업데이트 (Thread-Safe한 방식 사용)
        totalOrderCount.incrementAndGet();
    }

    // 내부 계산 로직 (상태를 저장하지 않는 순수 함수 형태가 좋음)
    private int calculateDiscount(int amount) {
        return (int) (amount * 0.9);
    }
}
```

### 빌더 패턴 (Builder Pattern)

- 정의
    - 복잡한 객체의 생성 과정과 표현 방법을 분리하여, 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있게 하는 패턴
    - 생성자의 매개변수가 많을 때 순서나 타입을 헷갈리지 않고, **필요한 데이터만 명시적으로 설정**하여 가독성을 높여줍니다.

<br>

실무 적용 예시 (Lombok @Builder)
- **동작 원리**: Java/Spring 실무에서는 수동으로 빌더 클래스를 구현하기보다, **Lombok 라이브러리의 `@Builder`** 어노테이션을 사용하여 컴파일 시점에 빌더 코드를 자동 생성합니다.
- **장점**: '점층적 생성자 패턴(Telescoping Constructor)'의 단점(null 파라미터 남발, 순서 혼동)을 해결하고, 객체의 **불변성(Immutability)**을 지키면서도 유연하게 객체를 생성할 수 있습니다.

```java
import lombok.Builder;
import lombok.Getter;

@Getter
@Builder // 이 어노테이션 하나로 내부 정적 빌더 클래스가 자동 생성됩니다.
public class User {
    private final String name;   // 필수
    private final String email;  // 필수
    private final int age;       // 필수
    private final String phone;  // 선택 (안 넣으면 null or 0)
}

// 서비스 계층에서의 사용 예시
public class UserService {
    
    public void createUser() {
        // [Before] 생성자 방식: 인자가 많으면 순서가 헷갈리고, 선택적 값에 null을 넣어야 함
        // User u1 = new User("홍길동", "hong@test.com", 30, null);

        // [After] 빌더 패턴: 메서드 체이닝으로 값을 주입하므로 가독성이 뛰어남
        // 필요한 필드만 골라서 설정 가능 (순서 상관 없음)
        User user = User.builder()
                .name("홍길동")
                .email("hong@test.com")
                .age(30)
                // .phone()은 선택값이므로 생략 가능
                .build();
        
        System.out.println("유저 생성 완료: " + user.getName());
    }
}
```

### 팩토리 메서드 패턴 (Factory Method Pattern)

- 정의
    - 객체 생성을 직접 하지 않고, **객체 생성을 전담하는 팩토리 클래스(또는 메서드)**에 위임하는 패턴
    - 클라이언트는 구체적인 클래스(NaverPay, KakaoPay 등)를 알 필요 없이, 공통 인터페이스만 사용하여 유연하게 기능을 확장할 수 있습니다.

<br>

실무 적용 예시 (결제 모듈 연동)
- **시나리오**: 쇼핑몰에서 결제 수단(네이버페이, 카카오페이, 토스 등)이 계속 추가되는 상황입니다.
- **동작 원리**: 주문 로직(`OrderService`)에서는 구체적인 PG사 API를 직접 호출(`new`)하지 않고, **팩토리에게 "이 결제 타입에 맞는 처리기를 줘"라고 요청**만 합니다. 이를 통해 결제 수단이 늘어나도 주문 비즈니스 로직은 수정할 필요가 없습니다(OCP 준수).

```java
// 1. 공통 인터페이스 (모든 결제사가 따라야 할 규격)
public interface PaymentProcessor {
    void pay(int amount);
}

// 2. 구체적인 구현체들 (각 PG사별 연동 로직)
class NaverPayProcessor implements PaymentProcessor {
    public void pay(int amount) { System.out.println("네이버페이 결제 요청: " + amount); }
}

class KakaoPayProcessor implements PaymentProcessor {
    public void pay(int amount) { System.out.println("카카오페이 결제 요청: " + amount); }
}

// 3. 팩토리 클래스 (객체 생성의 책임 담당)
public class PaymentFactory {
    public static PaymentProcessor create(String payType) {
        if ("NAVER".equals(payType)) {
            return new NaverPayProcessor();
        } else if ("KAKAO".equals(payType)) {
            return new KakaoPayProcessor();
        } else {
            throw new IllegalArgumentException("지원하지 않는 결제 수단입니다.");
        }
    }
}

// 4. 클라이언트 (주문 서비스)
public class OrderService {
    public void processOrder(String payType, int amount) {
        // 핵심: 클라이언트는 구체적인 클래스(NaverPayProcessor)를 몰라도 됨
        // 팩토리에게 생성을 위임하여 의존성을 제거
        PaymentProcessor processor = PaymentFactory.create(payType);
        
        processor.pay(amount);
    }
}
```

### 프로토타입 패턴 (Prototype Pattern)

- 정의
    - 새로운 객체를 생성할 때 처음부터(`new`) 생성하는 대신, **기존에 생성된 객체(Prototype)를 복제(Clone)**하여 사용하는 패턴
    - **DB 조회**나 **복잡한 계산** 등 생성 비용이 비싼 객체를 미리 만들어두고(Caching), 요청이 올 때마다 이를 복사해서 쓰면 성능을 획기적으로 개선할 수 있습니다.

<br>

실무 적용 예시 (DB 조회 비용 절감)
- **시나리오**: '새 프로젝트 생성' 기능을 수행할 때마다 수십 개의 '기본 가이드 문서'를 DB에서 조회해서 넣어줘야 하는 상황입니다.
- **동작 원리**: 매번 DB를 조회하는 것은 비효율적이므로, 애플리케이션 시작 시 **'마스터 템플릿'** 객체를 딱 한 번 만들어 DB 데이터를 로딩해 둡니다. 이후 사용자 요청이 오면 마스터 객체를 **복사(Copy)**하여 제공함으로써 DB 접근을 제거합니다.
- **구현 팁**: 실무에서는 Java의 `Cloneable` 인터페이스보다 **복사 생성자(Copy Constructor)** 방식을 사용하여 깊은 복사(Deep Copy)를 명시적으로 처리하는 것을 선호합니다.

```java
import java.util.ArrayList;
import java.util.List;

public class Project {
    private String name;
    private List<String> taskList;

    // 1. 일반 생성자
    public Project() {
        this.taskList = new ArrayList<>();
    }

    // DB에서 무거운 데이터를 가져오는 메서드 (비용이 비쌈)
    public void loadDefaultData() {
        try {
            // DB 조회 시뮬레이션 (2초 소요)
            Thread.sleep(2000); 
            taskList.add("기본: 팀원 초대하기");
            taskList.add("기본: 공지사항 읽기");
        } catch (InterruptedException e) { e.printStackTrace(); }
    }

    // 2. [핵심] 복사 생성자 (Copy Constructor)
    // 기존 객체(master)를 받아서 새로운 객체를 만듦
    public Project(Project master) {
        this.name = master.name; // 단순 필드 복사
        
        // [중요] 컬렉션은 반드시 깊은 복사(Deep Copy)를 해야 원본과 독립됨
        this.taskList = new ArrayList<>(master.taskList);
    }

    public void setName(String name) { this.name = name; }
}

// 서비스 계층 사용 예시
public class ProjectService {
    
    private Project masterTemplate;

    // 서버 시작 시(PostConstruct) 1회만 실행하여 캐싱
    public void initTemplate() {
        masterTemplate = new Project();
        masterTemplate.loadDefaultData(); // 2초 소요 (최초 1회만)
    }

    public Project createProject(String projectName) {
        // DB 접근 없이 메모리 복사로 순식간에 생성 (성능 최적화)
        Project newProject = new Project(masterTemplate);
        newProject.setName(projectName);
        
        return newProject;
    }
}
```

