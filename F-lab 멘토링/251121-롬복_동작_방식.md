# lombok 동작 방식

## Annotation Processor

- 롬복은 JSR-269 표준을 따르는 어노테이션 프로세서이다
    1. `javac`(또는 Gradle/Maven 빌드) 실행
    2. 컴파일러가 소스 코드를 파싱해서 AST(추상 구문 트리) 생성
    3. 이때 `@Getter`, `@Setter`, `@Builder` 같은 롬복 어노테이션을 발견
    4. 롬복의 어노테이션 프로세서가 AST를 조작해서 어노테이션에 해당하는 메소드/생성자 등 생성
    5. 수정된 AST 기준으로 `.class` 파일 생성
- 오로지 컴파일할 때 소스/AST를 만져서 코드 생성만 한다

## Lombok이 Javac 컴파일 과정 중 AST를 조작하는 시점

- 롬복은 Javac의 어노테이션 프로세싱 단계만 사용하는 것이 아니다
- Javac의 파싱 이후, 심볼 분석 이전/중간 단계에서 AST를 직접 수정한다
    1. 소스 코드 파싱 -> AST 생성
    2. 여기서 롬복이 AST를 가로채서 메소드 추가 <- 이 단계
    3. 심볼 분석(attribute) : 추가된 메소드도 함께 타입 체킹
    4. 바이트코드 생성(generate) : 수정된 AST 기반으로 .class 파일 생성
- 파싱 전에 개입하면 소스 코드 문법이 아직 검증되지 않아 롬복이 작업할 수 있는 AST가 존재하지 않는다
- 심볼 분석이 끝난 뒤에는 타입 체크가 끝나서 새로운 메소드를 추가할 수 없으며 .class 생성 단계로 넘어가 버린다
- 롬복이 가능한 이유는, 롬복이 일반 어노테이션 프로세서가 아니라 Javac 내부 API를 직접 사용하여 Javac 컴파일러의 내부 AST를 변조하는 비공식적 트릭을 사용한다

## 롬복이 Javac 내부 AST를 직접 조작한다면, 왜 빌드 도구(Maven/Gradle)에서도 롬복 설정이 필요한가?

- 롬복이 AST를 조작하려면 반드시 컴파일 단계에 Javac 안으로 끼어들어야 하는데, 그 통로가 어노테이션 프로세서이다
- 롬복이 AST를 조작하는 능력은 Javac 컴파일 과정에서만 가능하며, 빌드 도구는 롬복을 Javac에 연결해주기 위해 어노테이션 프로세서로 등록해야 한다. 또한 런타임에는 롬복이 필요없으므로 complieOnly로만 포함한다

## IDE 플러그인이 필요한 이유

- IDE는 내가 작성한 소스 파일 그대로를 보고 코드 분석을 한다
- 롬복이 생성한 메소드는 소스 파일에는 없고, AST에만 존재한다
- 따라서 :
    - 롬복 플러그인이 없는 상태 -> IDE가 `get메소드명()`이 없다고 인지
    - 컴파일은 잘 되지만, IDE가 이해하지 못하는 상황
- 그래서 IDE마다 롬복 플러그인을 설치해서 롬복이 이런 메소드를 만들어 줄거라고 IDE에게 알려준다

## 실제 동작

1. 롬복 어노테이션을 붙인다
2. IDE 플러그인으로 인해 IDE는 메소드가 존재하는 것처럼 인식한다
3. 빌드할 때 컴파일러 + 롬복 어노테이션 프로세서가 진짜 메소드를 가진 `.class` 파일을 출력한다
4. 런타임(서버 구동, 배포 환경)에서는 그냥 getter/setter가 있는 평범한 클래스로 보인다

## 한 줄 요약

롬복은 자바 어노테이션 프로세서를 이용해 컴파일 타임에 AST를 조작해, getter/setter 같은 메소드를 자동으로 생성해주는 라이브러리입니다. 런타임 시점에 동작하는게 아닌, 컴파일 시점 코드 생성이라서 빌드 결과물은 일반 자바 클래스입니다.