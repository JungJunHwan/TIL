## Heap

### “JVM의 메모리 구조에서 ‘Heap 영역’의 역할과 내부 구성 요소를 설명해주세요.”

나의 답변
- Heap은 자바에서 모든 객체와 배열이 실제로 저장되는 영역입니다. 힙 영역은 Young/Old 영역으로 나뉘는데 이때 Young 영역은 Eden과 Survivor (S0, S1)으로 나뉩니다. 객체 생성시 Eden에 생성되며 Young GC(Minor GC)에서 생존한 객체는 Survivor로 복사되어 옮겨집니다. threshold 이상의 GC에서 생존한 객체는 Old Generation으로 promotion 됩니다.

보완 요소
- 세대를 분리한 이유
    - 대부분의 객체는 금방 죽어서 Young 영역은 빠르게 자주 청소하고, Old 영역은 가끔 청소함으로써 전체 GC의 효율을 극대화 한다


### “Minor GC 도중 어떤 객체들은 Survivor로 가지 않고 ‘바로 Old로 승격(promotion)’됩니다. 이 ‘바로 승격’이 발생하는 대표 조건들을 모두 설명하고, 그로 인해 생길 수 있는 문제(예: promotion failure)와 이를 완화하기 위한 튜닝 포인트(대표 JVM 옵션들 포함)를 말해보세요.”

나의 답변
- 모르겠음

보완 요소
- 바로 Old로 promotion 되는 대표 조건
    1. 객체의 크기가 너무 커서 Young에 담지 못할 때
        - 대형 배열이나 거대한 객체는 Eden / Survivor에 한 번도 안들어가고 바로 Old로 가는데 이를 Pretenuring이라고 한다
        - JVM은 `-XX:PretenureSizeThreshold` 옵션으로 이 임계값을 조정할 수 있다 (단, Serial/Parallrl GC에서만 적용, G1에서는 무시됨)
    2. Survivor 공간이 부족할 때
        - Survivor의 S0/S1이 꽉 차면 남은 객체는 어쩔 수 없이 Old로 승격된다
        - 이를 Promotion failure라고 한다
        - 이때 Old 영역의 여유도 부족하면 Full GC(Minor GC)로 이어질 수 있다
    3. 객체의 Age가 임계값을 넘을 때
        - Survivor에 남아있는 객체는 Minor GC 때마다 age가 +1된다
        - 특정 age(기본 15, `-XX:maxTenuringThreshold`로 조정) 이상이 되면 Old로 승격된다
        - 하지만, 동적 기준(Adaptive Tenuring)이 적용되어 Survivor 내 비율에 따라 승격 시점이 자동으로 조정되기도 한다
    4. G1 GC의 경우
        - G1은 Region 단위로 관리하며, Eden/Survivor/Old가 논리적으로만 구분된다
        - Survivor 크기가 작거나 Region 회수가 적으면 promotion이 자주 일어나며, G1의 `Humongous Region` 정책에 따라 큰 객체는 바로 Old Region으로 들어간다

- 대표 튜닝 포인트

| 목적 | JVM 옵션 | 설명 |
| --- | --- | --- |
| 대형 객체를 바로 Old로 보낼 임계값 | `-XX:PretenureSizeThreshold=<bytes>` | Eden에 넣지 않고 바로 Old로 |
| 객체 승격 기준 age 조정 | `-XX:MaxTenuringThreshold=<n>` | 생존 횟수 조정 (기본 15) |
| Survivor 비율 조정 | `-XX:SurvivorRatio=<n>` | Eden:Survivor 비율 (기본 8:1:1) |
| Old 영역 크기 조정 | `-Xmx`, `-Xms`, `-XX:NewRatio` | 전체 및 세대별 메모리 비율 조절 |

- 한 줄 요약
    - **Eden에서 Old로 바로 가는 이유는 공간 부족, 객체 크기, 생존 횟수 초과 때문이며, 이 과정이 잦아지면 Promotion Failure -> Full GC로 이어질 수 있다**

### “Eden과 Survivor의 크기 비율(SurvivorRatio)을 잘못 조정하면 어떤 부작용이 생기며, GC 성능에는 어떤 영향을 주나요?”

나의 답변
- Survivor가 너무 작을 때는 공간이 부족해 Old로 바로 승격하는 경우가 발생할 수 있고 그에 따라 Old의 공간도 부족해져 Promotion Failure가 발생해 Full GC로 이어져 긴 STW로 인한 성능 저하가 발생할 수 있습니다. Survivor가 너무 클 경우엔 빈번한 Young GC로 인해 성능 저하가 발생할 수 있습니다.

보완 요소
- Survivor가 너무 크면 Eden 영역이 상대적으로 작아진다 (Young 전체 크기 = Eden + 2 * Survivor)
- Eden이 작으면 객체가 금방 차기 때문에 Minor GC 빈도가 증가해 성능 저하의 원인이 된다
- Survivor 비율 조정은 단순히 메모리 낭비 문제가 아니라, GC 주기와 객체 승격 패턴을 함께 바꾸기 때문에 GC 튜닝에서는 항상 Eden 크기와 함께 조합해 조정합니다

### “GC 로그를 통해 Survivor 공간이 너무 작거나 큰지를 어떻게 판단할 수 있을까요? 즉, GC 로그를 분석할 때 어떤 지표를 보면 Survivor 튜닝이 필요한지 설명해보세요.”

나의 답변
- Minor GC 로그에서 Eden/Survivor의 사용률, promotion 비율, 평균 생존 객체 비율을 확인합니다. Eden/Survivor 사용률에서 Eden의 사용률이 높다면 Survivor의 크기가 너무 작은것이고, 반대라면 크기가 너무 큰 것입니다. 또한 promotion 비율이 높거나 평균 생존 객체 비율이 높다면 Survivor의 크기가 작아 발생한 것이므로 Survivor의 크기를 키워 튜닝할 수 있습니다

보완 요소
- Eden 사용률이 높다고 해서 Survivor가 작다고 단정짓는건 위험하다
- 판단은 승격 바이트/비율, Survivor 포화 징후, tenuring 분포를 함께 봐야한다
    - 승격량(Promotion bytes) 추세가 높고 빈번한가?
        - Survivor 부족 / Old 압박
    - Survivor after-GC 사용률이 항상 상한 근처인가?
        - Survivor 부족
    - Eden이 너무 자주 비워짐(Young GC 빈도 증가) + Survivor가 한산
        - Survivor 과대 혹은 Eden 축소 가능성
    - age 분포 대비 threshold 에서 조기 승격이 많나?
        - `MaxTenuringThreshold` 재검토

## Stack