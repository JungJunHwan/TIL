## Heap

### “JVM의 메모리 구조에서 ‘Heap 영역’의 역할과 내부 구성 요소를 설명해주세요.”

나의 답변
- Heap은 자바에서 모든 객체와 배열이 실제로 저장되는 영역입니다. 힙 영역은 Young/Old 영역으로 나뉘는데 이때 Young 영역은 Eden과 Survivor (S0, S1)으로 나뉩니다. 객체 생성시 Eden에 생성되며 Young GC(Minor GC)에서 생존한 객체는 Survivor로 복사되어 옮겨집니다. threshold 이상의 GC에서 생존한 객체는 Old Generation으로 promotion 됩니다.

보완 요소
- 세대를 분리한 이유
    - 대부분의 객체는 금방 죽어서 Young 영역은 빠르게 자주 청소하고, Old 영역은 가끔 청소함으로써 전체 GC의 효율을 극대화 한다


### “Minor GC 도중 어떤 객체들은 Survivor로 가지 않고 ‘바로 Old로 승격(promotion)’됩니다. 이 ‘바로 승격’이 발생하는 대표 조건들을 모두 설명하고, 그로 인해 생길 수 있는 문제(예: promotion failure)와 이를 완화하기 위한 튜닝 포인트(대표 JVM 옵션들 포함)를 말해보세요.”

나의 답변
- 모르겠음

보완 요소
- 바로 Old로 promotion 되는 대표 조건
    1. 객체의 크기가 너무 커서 Young에 담지 못할 때
        - 대형 배열이나 거대한 객체는 Eden / Survivor에 한 번도 안들어가고 바로 Old로 가는데 이를 Pretenuring이라고 한다
        - JVM은 `-XX:PretenureSizeThreshold` 옵션으로 이 임계값을 조정할 수 있다 (단, Serial/Parallrl GC에서만 적용, G1에서는 무시됨)
    2. Survivor 공간이 부족할 때
        - Survivor의 S0/S1이 꽉 차면 남은 객체는 어쩔 수 없이 Old로 승격된다
        - 이를 Promotion failure라고 한다
        - 이때 Old 영역의 여유도 부족하면 Full GC(Minor GC)로 이어질 수 있다
    3. 객체의 Age가 임계값을 넘을 때
        - Survivor에 남아있는 객체는 Minor GC 때마다 age가 +1된다
        - 특정 age(기본 15, `-XX:maxTenuringThreshold`로 조정) 이상이 되면 Old로 승격된다
        - 하지만, 동적 기준(Adaptive Tenuring)이 적용되어 Survivor 내 비율에 따라 승격 시점이 자동으로 조정되기도 한다
    4. G1 GC의 경우
        - G1은 Region 단위로 관리하며, Eden/Survivor/Old가 논리적으로만 구분된다
        - Survivor 크기가 작거나 Region 회수가 적으면 promotion이 자주 일어나며, G1의 `Humongous Region` 정책에 따라 큰 객체는 바로 Old Region으로 들어간다

- 대표 튜닝 포인트

| 목적 | JVM 옵션 | 설명 |
| --- | --- | --- |
| 대형 객체를 바로 Old로 보낼 임계값 | `-XX:PretenureSizeThreshold=<bytes>` | Eden에 넣지 않고 바로 Old로 |
| 객체 승격 기준 age 조정 | `-XX:MaxTenuringThreshold=<n>` | 생존 횟수 조정 (기본 15) |
| Survivor 비율 조정 | `-XX:SurvivorRatio=<n>` | Eden:Survivor 비율 (기본 8:1:1) |
| Old 영역 크기 조정 | `-Xmx`, `-Xms`, `-XX:NewRatio` | 전체 및 세대별 메모리 비율 조절 |

- 한 줄 요약
    - **Eden에서 Old로 바로 가는 이유는 공간 부족, 객체 크기, 생존 횟수 초과 때문이며, 이 과정이 잦아지면 Promotion Failure -> Full GC로 이어질 수 있다**

### “Eden과 Survivor의 크기 비율(SurvivorRatio)을 잘못 조정하면 어떤 부작용이 생기며, GC 성능에는 어떤 영향을 주나요?”

나의 답변
- Survivor가 너무 작을 때는 공간이 부족해 Old로 바로 승격하는 경우가 발생할 수 있고 그에 따라 Old의 공간도 부족해져 Promotion Failure가 발생해 Full GC로 이어져 긴 STW로 인한 성능 저하가 발생할 수 있습니다. Survivor가 너무 클 경우엔 빈번한 Young GC로 인해 성능 저하가 발생할 수 있습니다.

보완 요소
- Survivor가 너무 크면 Eden 영역이 상대적으로 작아진다 (Young 전체 크기 = Eden + 2 * Survivor)
- Eden이 작으면 객체가 금방 차기 때문에 Minor GC 빈도가 증가해 성능 저하의 원인이 된다
- Survivor 비율 조정은 단순히 메모리 낭비 문제가 아니라, GC 주기와 객체 승격 패턴을 함께 바꾸기 때문에 GC 튜닝에서는 항상 Eden 크기와 함께 조합해 조정합니다

### “GC 로그를 통해 Survivor 공간이 너무 작거나 큰지를 어떻게 판단할 수 있을까요? 즉, GC 로그를 분석할 때 어떤 지표를 보면 Survivor 튜닝이 필요한지 설명해보세요.”

나의 답변
- Minor GC 로그에서 Eden/Survivor의 사용률, promotion 비율, 평균 생존 객체 비율을 확인합니다. Eden/Survivor 사용률에서 Eden의 사용률이 높다면 Survivor의 크기가 너무 작은것이고, 반대라면 크기가 너무 큰 것입니다. 또한 promotion 비율이 높거나 평균 생존 객체 비율이 높다면 Survivor의 크기가 작아 발생한 것이므로 Survivor의 크기를 키워 튜닝할 수 있습니다

보완 요소
- Eden 사용률이 높다고 해서 Survivor가 작다고 단정짓는건 위험하다
- 판단은 승격 바이트/비율, Survivor 포화 징후, tenuring 분포를 함께 봐야한다
    - 승격량(Promotion bytes) 추세가 높고 빈번한가?
        - Survivor 부족 / Old 압박
    - Survivor after-GC 사용률이 항상 상한 근처인가?
        - Survivor 부족
    - Eden이 너무 자주 비워짐(Young GC 빈도 증가) + Survivor가 한산
        - Survivor 과대 혹은 Eden 축소 가능성
    - age 분포 대비 threshold 에서 조기 승격이 많나?
        - `MaxTenuringThreshold` 재검토

---

## Stack

### “Stack 영역은 어떤 역할을 하며, ‘스레드마다 별도로 존재한다’는 말의 정확한 의미는 무엇인가요? 또한 `StackOverflowError`는 어떤 상황에서 발생하나요?”

나의 답변
- 스택 영역은 메서드가 실행될 때 임시로 필요한 메모리 공간을 제공하는 영역입니다. 스택오버플로우는 스택에 너무 많은 스택 프레임이 쌓여 공간이 부족해 더 이상 스택 프레임을 쌓을 수 없을 때 발생합니다.

보완 요소
- 스택 프레임은 로컬 변수 테이블, 오퍼랜드 스택, 프레임 데이터로 구성된 구조를 가지고 있어 JVM이 호출/리턴을 스택 기반으로 관리할 수 있습니다.
- JVM은 각 스레드마다 독립된 스택 영역을 생성합니다. 즉, 스레드 간 스택은 공유되지 않으며, 각자 자기만의 호출 스택을 가집니다. 이를 통해 스레드 안전성을 보장합니다.
- `StackOverFlowError`는 메서드가 너무 깊게 재귀 호출되거나, 무한 루프처럼 종료되지 않고 프레임이 계속 쌓일 때 발생합니다

### “스택에 저장된 데이터(지역 변수나 매개변수)는 GC의 대상이 되나요? 만약 GC가 스택 데이터를 건드리지 않는다면, 스택에서 참조 중인 객체는 어떻게 처리되나요?”

나의 답변
- 스택에 저장된 데이터는 GC의 대상이 되지 않습니다. GC는 Heap만 관리하기 때문입니다. 스택이 참조 중인 객체는 GC에서 살아남게 됩니다

보완 요소
- 스택이 참조 중인 객체는 Reachable 상태이므로 GC가 수거하지 않는다. GC Root에서 출발해 참조를 따라갈 수 있는 객체는 살아 있다고 간주한다
- 대표적인 GC Root는 다음과 같다
    - 스택 프레임 내의 지역 변수 / 매개변수 참조
    - 메서드 실행 중인 스레드의 레지스터
    - static 변수
    - JNI
- 즉, 스택의 참조 변수(객체)들은 GC Root로 간주되어 도달 가능한 상태이므로 GC의 수거 대상에서 제외된다

### “static 변수와 메서드 내부의 지역 변수는 둘 다 객체를 참조할 수 있습니다. 그렇다면 GC 관점에서 두 변수의 차이는 무엇인가요?”

나의 답변
- 메서드 내부의 지역 변수는 메서드 수행이 끝나면 참조가 끊어져 GC의 수거 대상이 되지만, static 변수는 자바 프로그램이 종료될 때까지 살아있기 때문에 참조가 지속되어 GC의 수거 대상이 되지 않습니다

보완 요소
- static 변수는 Metaspace에 저장됩니다. 이는 객체가 아닌 클래스 자체에 속함을 의미하는데, static 변수의 객체 참조는 클래스가 JVM에 로드될 때 초기화되고, 해당 클래스 로더가 언로드되기 전까지 유지되어 GC Root로 간주되어 참조가 유지되는 한 해당 객체는 GC가 회수하지 않습니다

### “static 변수가 메모리 누수를 일으킬 수 있다는 말은 무슨 뜻인가요? 그리고 실제로 어떤 상황에서 static 변수가 GC를 방해하는지 예시를 들어 설명해주세요.”

나의 답변
- static 변수는 클래스 로더가 유지되는 한 GC의 대상이 되지 않습니다. 따라서, 사용되고 있지 않더라도 메모리를 차지하고 있어 메모리 누수를 일으킵니다. 예를 들어 static으로 List나 Map에 지속적으로 객체를 추가하고 제거하지 않으면 많은 객체의 참조가 유지되어 GC Root로 간주되어 GC의 대상이 되지 않아 메모리 누수를 일으키는 원인이 됩니다.

보완 요소
- 자바에서 메모리 누수는 더 이상 사용되지 않지만, GC가 수거할 수 없는 객체가 존재하는 상황을 말한다
- 즉, 도달성(reachability)은 있지만 의미상 사용되지 않는 객체이다
- 이를 방지하기 위해선 static 컬렉션 사용 시 명시적 clear() 호출을 하거나, WeakReference/WeakHashMap을 사용해 GC에 회수될 수 있도록 구성하거나, 필요 시 클래스 로더 언로드를 통해 static 메모리를 해제하면 됩니다

---

## Metaspace

### “Metaspace는 어떤 역할을 하는 영역인가요? 그리고 Java 8 이전의 PermGen(Permanent Generation)과 비교했을 때 어떤 차이가 있나요?”

나의 답변
- Metaspace는 클래스의 메타데이터가 저장되는 영역으로, JVM이 로딩한 클래스의 정보가 저장되는 공간입니다. PermGen은 크기가 고정되어 OutOfMemery가 자주 발생하고, 클래스가 언로드 돼도 내부 메모리를 GC가 잘 수거하지 못했고, 힙 영역에 있었기 때문에 OS의 네이티브 메모리와 연동이 비효율적이었다. Metaspace는 크기를 자동으로 확장할 수 있고, 클래스 언로드시 GC가 잘 수거할 수 있었으며, 네이티브 메모리 영역에 있습니다

### “Metaspace는 네이티브 메모리를 사용해 자동으로 확장된다고 했습니다. 그렇다면 왜 여전히 `OutOfMemoryError: Metaspace`가 발생할 수 있을까요? 그리고 실제로 어떤 상황에서 이런 문제가 자주 발생하나요?”

나의 답변
- 물리적으로 OS 메모리가 부족할 때 발생할 수 있습니다.

보완 요소
- JVM 옵션으로 최대 크기를 설정한 경우와 물리적 OS 메모리가 부족할 경우 발생할 수 있다
- 실무에서 자주 발생하는 상황
    - 클래스 로더 누수 (ClassLoader Leak)
        - WepApp 재배포 시, 클래스 로더가 해제되지 않고 새로 로드됨
        - 과거 클래스 정보들이 계속 남아 Metaspace에 쌓임
        - 대표적으로 Tomcat, WebLogic, Spring Boot DevTools 재시작 시 자주 발생
    - 무한한 동적 클래스 생성
        - 예 : 프록시, 리플렉션, 바이트코드 조작 도구
            - Hibernate, Spring CGLIB Proxy, Javassist, Groovy, ASM 등
        - 지속적으로 새로운 클래스를 JVM에 로딩하면 Metaspace가 끝없이 커짐
    - 오랫동안 해제되지 않는 ClassLoader 보유 객체
        - 예 : static Map에 ClassLoader를 참조하는 경우
        - GC는 ClassLoader 단위로 Metaspace를 해제하므로, 참조가 남으면 메모리 누수가 발생

한 줄 정리
- Metaspace는 OS 네이티브 메모리를 사용하므로 물리적으로 무한하지 않으며, ClassLoader 누수나 동적 클래스 로딩이 누적될 때 OutOfMemoryError가 발생한다

### “GC는 언제 Metaspace를 청소하나요? 즉, 클래스 언로드(Class Unloading)는 어떤 조건에서 발생하나요?”

나의 답변
- 모르겠음

보완 요소
- GC는 클래스 언로드가 가능한 경우에만 Metaspace의 메모리를 해제한다
- 모든 GC마다 자동으로 언로드 되는것이 아닌, 클래스 로더와 연결된 클래스들이 더 이상 참조되지 않을 때만 언로드됩니다
- 클래스 언로드 조건
    - ClassLoader 객체가 더 이상 참조되지 않을 것
        - Heap 어딘가에서 해당 로더를 참조하는 변수가 없어야 함
    - 그 로더가 로드한 클래스들도 더 이상 참조되지 않을 것
        - Heap의 어떤 객체도 해당 클래스의 타입으로 존재하지 않아야 함
    - GC가 Full GC(또는 Concurrent Class Unloading 지원시, Major GC) 수행 중일 것

한 줄 정리
- 클래스 언로드는 GC 시점이 아니라, ClassLoader가 참조 해제될 때 발생하며, 그때 Metaspace에 저장된 클래스 메타데이터가 청소된다.

---

## Native Method Stack

### “Native Method Stack은 어떤 역할을 하는 영역인가요? 그리고 일반적인 Stack 영역과 어떤 차이가 있나요?”

나의 답변
- 네이티브 메서드를 실행할 때 사용하는 스택 영역입니다. 네이티브 메서드는 JNI를 통해 사용할 수 있는데 네이티브 메서드 호출 시 자바 스택에서 네이티브 스택으로 제어를 넘기고, 마치면 다시 자바 스택으로 돌아갑니다

보완 요소
- 자바 스택과의 차이점

| 구분         | Java Stack             | Native Method Stack                        |
| ---------- | ---------------------- | ------------------------------------------ |
| **용도**     | 자바 메서드 실행용             | 네이티브 메서드 실행용                               |
| **언어**     | Java 바이트코드             | C, C++ 등의 네이티브 코드                          |
| **생성 주체**  | JVM이 스레드 생성 시 함께 생성    | JVM이 네이티브 호출 시 생성                          |
| **GC 연관성** | GC Root에 포함 (참조 추적 가능) | GC와 직접 관련 없음 (단, JNI 참조는 Root로 인식됨)        |
| **예외 종류**  | `StackOverflowError`   | `StackOverflowError` 또는 `OutOfMemoryError` |

한 줄 정리
- Native Method Stack을 JNI를 통해 C/C++ 네이티브 코드를 실행할 때 사용하는 별도 스택으로, 자바 스택과는 독립적으로 존재하지만 스레드 단위로 함께 관리된다

### “JVM에서 Java Stack과 Native Method Stack은 물리적으로 완전히 분리된 영역일까요? 아니면 구현체(예: HotSpot JVM)에서는 통합되어 있을까요?”

나의 답변
- 모르겠습니다

보완 요소
- 스펙 관점
    - JVM 명세에 따르면 둘은 별개의 영역으로 정의되어 있다고 한다
    - 이유는 JVM 구현체마다 네이티브 코드를 실행하는 방식이 다르기 때문이다
- 실제 HopSpot JVM 구현
    - HopSpot JVM에서는 두 스택이 물리적으로 통합되어 있다
    - 즉 자바 스택과 네이티브 스택은 동일한 OS 스레드 스택을 공유한다
    - 따라서 JNI 호출이 일어나도, 단순히 같은 스택 위에서 네이티브 코드로 제어가 넘어가는 형태로 동작한다
    - 이유
        - HotSpot JVM은 자바 스레드와 OS 스레드가 1:1로 매핑된다
        - OS 스레드 자체가 이미 스택을 가지고 있기 때문에, 굳이 둘로 나눌 필요가 없다
        - 따라서 네이티브 메서드 실행 시 동일한 스택 프레임 상에서 JNI 코드가 수행된다

한 줄 정리
- JVM 스펙상으로는 자바 스택과 네이티브 스택은 별도지만, HotSpot 같은 실제 구현에서는 하나의 통합된 OS 스레드 스택으로 관리된다

### “StackOverflowError와 OutOfMemoryError: unable to create new native thread는 둘 다 스택 관련 에러처럼 보입니다. 하지만 이 둘은 근본적으로 어떤 차이가 있나요?”

나의 답변
- 모르겠습니다

보완 요소
- StackOverflowError
    - 이미 존재하는 스레드의 스택이 넘친 상황
    - 발생 조건
        - 하나의 스레드 내부에서 스택 프레임이 너무 깊게 쌓여 해당 스레드의 스택 크기 한도를 초과한 경우 발생
    - 주 원인
        - 깊은 재귀 호출
        - 메서드 호출이 너무 중첩되어 스택 프레임이 누적
- OutOfMemoryError: unable to create new native thread
    - 새 스레드를 만들 수 없는 상황
    - 발생 조건
        - 새로운 스레드를 생성하려 할 때 운영체제가 해당 스레드용 스택 공간을 더 이상 할당할 수 없을 때 발생
    주 원인
        - 스레드 수 과도
        - OS 레벨 스레드 한계 초과
        - 전체 시스템 메모리 부족으로 스택 공간 확보 실패

한 줄 정리
- StackOverflowError는 하나의 스레드 안에서 스택이 넘친 경우, OutOfMemoryError: unable to create new native thread는 새 스레드를 만들 수 없을 경우 발생합니다

---

## PC Register

### “JVM의 PC Register는 어떤 역할을 하는 영역인가요? 그리고 스레드마다 별도로 존재한다는 말은 무슨 의미인가요?”

나의 답변
- 현재 실행중인 명령어의 위치를 저장하는 공간이다. 스레드마다 별도로 존재하는 이유는 지금 이 스레드가 자바 바이트코드 어디를 실행중인지 알아야 하기 때문입니다.

보완 요소
- JVM이 실행 중인 바이트코드 명령어의 주소(라인 번호)를 저장하는 공간
- JVM은 멀티스레드 환경에서 각 스레드가 동시에 다른 메서드를 실행할 수 있기 때문에, 스레드마다 어디까지 실행했는지를 별도로 추적해야 한다
- 네이티브 메서드는 자바 바이트코드를 실행하지 않기 때문에, 해당 스레드의 PC Register는 undefined 상태 또는 0으로 둔다

### “JVM은 PC Register를 통해 현재 실행 중인 바이트코드의 위치를 추적합니다. 그런데 JIT 컴파일이 적용되어 바이트코드가 네이티브 코드로 변환된 경우, JVM은 실행 위치를 어떻게 추적하나요?”

나의 답변
- 모르겠습니다

보완 요소
- JIT 컴파일이 활성화되면, 바이트코드 일부가 머신 코드(네이티브 코드)로 변한되어 CPU에서 직접 실행된다
- 이때는 바이트코드 주소가 아닌 CPU 명령어 주소를 기준으로 실행된다
- JIT 후에 PC Register는 어떻게 동작하나?
    - JIT 컴파일된 코드는 CPU 레벨의 레지스터(하드웨어 PC)를 사용한다
    - 즉, JVM의 논리적 PC Register는 더 이상 명령어 포인터 역할을 수행하지 않는다
    - 대신 JVM 내부에서는 바이트코드 <-> 네이티브 코드 주소 매핑 테이블을 유지한다
- 동작 과정
    1. 바이트코드 실행 중 JIT 트리거 발생
    2. JIT 컴파일러는 BCI와 네이티브 코드의 싲가 주소를 매핑해 내부 테이블에 기록한다
    3. JVM은 JIT 코드 실행 중에도 예외 처리, 디버깅, 스택 트레이스 등을 위해 BCI를 역으로 계산할 수 있다
    4. 즉, PC Register는 논리적으로 존재하지만, 실제 주소는 매핑 테이블을 통해 간접적으로 추적된다

한 줄 정리
- JIT 컴파일 되어도 JVM 은 바이트코드와 네이티브 코드의 주소 매핑 정보를 유지합니다. 따라서 실제 실행은 CPU의 물리적 PC Register가 담당하지만, JVM은 내부 테이블을 통해 논리적 바이트코드 PC를 추적할 수 있다

---

## Runtime Constant Pool

### “Runtime Constant Pool은 어떤 역할을 하는 영역인가요? 그리고 Class 파일의 Constant Pool과는 어떤 차이가 있나요?”

나의 답변
- RCP는 클래스나 인터페이스마다 클래스 로딩 시 Metaspace에 만들어지는 상수 테이블입니다. Class 파일 로딩 시점의 정적 Constant Pool이 JVM 실행 중에는 RCP로 변환되어 참조, 리터럴, 심볼 정보 드을 저장합니다

보완 요소
- RCP는 각 클래스나 인터페이스가 JVM에 로드될 때, 그 클래스의 Constant Pool 테이블을 메모리상에 올려놓은 구조입니다
- 쉽게 말하면 클래스 파일에 있던 상수, 참조 정보들을 JVM이 실제로 사용할 수 있도록 변환한 버전입니다
- 저장되는 항목

| 구분                            | 예시                            | 설명                                 |
| ----------------------------- | ----------------------------- | ---------------------------------- |
| 리터럴 값(Literal)           | `"Hello"`, `3.14`, `100`      | 컴파일 시 결정된 상수 값                     |
| 심볼릭 참조(Symblic Reference) | 클래스 이름, 메서드 이름, 필드 이름 등       | 실제 메모리 주소로 변환되기 전의 논리적 참조          |
| final 상수                  | `static final int VALUE = 10` | 상수로 컴파일된 값                         |
| 메서드/필드 참조 정보              | `invokevirtual`, `getfield` 등 | 실행 시 실제 메서드/필드 주소로 해석됨             |
| String literal 상수         | `"abc"`                       | intern() 시 String Pool에 저장 후 참조 유지 |

- 메모리 위치는 자바 7 이전엔 PermGen, 자바 8 이후론 Metaspace 내부의 RCP에 저장
- "Hello" 같은 문자열 리터럴은 RCP에 기존 문아ㅕㄹ이 있는지 확인 후, 없으면 Heap의 String Pool에 저장된다
- 이후 같은 문자열 리터럴은 String Pool의 참조를 재사용한다
- RCP는 리터럴을 참조하는 위치, String Pool은 리터럴의 실제 객체

한 줄 정리
- RCP는 클래스 로딩 시 Metaspace에 생성되는 상수 테이블로, 클래스 파일의 Constant Pool을 런타임에서 사용할 수 있도록 해석한 구조입니다

### “`"abc"` 같은 문자열 리터럴은 RCP와 Heap 중 어디에 저장되나요? 그리고 `new String("abc")` 로 생성한 문자열과는 어떤 차이가 있나요?”

나의 답변
- 리터럴은 RCP에 올라가지만 실제 객체는 Heap의 String Pool에 저장됩니다. new를 사용해 생성한 문자열은 항상 새로운 객체를 생성하기 때문에 같은 Heap에 있지만 String Pool에 저장되지 않습니다

보완 요소
- 리터럴은 클래스 로딩 시점에 RCP에 등록되며, JVM은 리터럴이 String Pool에 있는지 확인한다
- 없으면 새로 생성하여 String Pool에 저장하고, RCP는 그 참조를 보유한다
- 다음에 같은 문자열의 리터럴이 등장하면 RCP는 기존 String Pool의 참조를 재사용한다

### “String.intern() 메서드는 어떤 역할을 하나요? 그리고 이 메서드를 과도하게 사용하면 오히려 성능 문제가 생길 수 있는 이유는 무엇인가요?”

나의 답변
- intern() 메서드는 문자열을 String Pool에 등록해주는 역할을 합니다.

보완 요소
- 중복 문자열이 매우 많을 때 메모리 절약이 가능해 유용하다
- 남용시 위험요소
    - String Pool 공간은 무한하지 않다
    - intern() 호출 자체가 비용이 든다
        - JVM은 intern() 시 동기화된 전역 테이블 검색을 수행해야 한다
    - 문자열 관리가 GC Root를 통해 계속 유지된다
        - 한 번 intern() 된 문자열을 GC에서 쉽게 해제되지 않는다
            - 불필요한 문자열까지 Pool에 남으면 메모리 누수처럼 작동한다

한 줄 정리
- intern()은 문자열을 String Pool에 등록해 중복을 제거하지만, 너무 많이 사용하면 Pool 메모리 포화와 락 경합으로 오히려 성능이 저하될 수 있다

---

## Code Cache

### “Code Cache는 어떤 역할을 하는 영역인가요? 그리고 JIT 컴파일과 어떤 관계가 있나요?”

나의 답변
- Code Cache는 JIT가 자주 사용되는 메서드의 자바 바이트코드를 네이티브 코드로 바꿔 저장하는 메모리 영역입니다.

보완 요소
- Code Cache는 JIT 컴파일 결과의 저장소이며, 컴파일 된 메서드는 다음부터 인터프리터가 아닌 Code Cache에 저장된 네이티브 코드를 직접 실행한다
- HotSpot JVM에서는 Code Cache가 세 가지 영역으로 분리된다
    1. Non-profiled code : 단순 JIT 컴파일된 코드
    2. Profiled code : 최적화된 C2 컴파일 결과
    3. Non-method code : JVM 내부용 코드

한 줄 정리
- Code Cache는 JIT 컴파일을 통해 생성한 네이티브 코드를 저장하는 영역으로, 자주 실행되는 메서드를 캐싱해 실행 속도를 크게 향상시킵니다

### “Code Cache가 가득 차면 JVM은 어떤 동작을 하나요? 그리고 왜 Code Cache의 크기를 무작정 늘린다고 해서 성능이 항상 좋아지는 것은 아닐까요?”

나의 답변
- Code Cache가 가득 차면 JIT 컴파일이 중단되어 인터프리터로 되돌아갑니다.

보완 요소
- 크기를 늘린다고 해서 성능이 항상 좋아지지 않는 이유
    - 캐시 관리 오버헤드 증가
        - Code Cache는 단순 저장 공간이 아니라 JIT가 관리하는 구조체이다
        - 너무 크면 캐시 검색, 삭제, 관리 비용이 커져 성능 저하가 발생한다
    - CPU의 Instruction Cache(I-Cache) 효율 저하
        - Code Cache는 결국 CPU 명령어 캐시(I-Cache)에서 실행된다
        - 너무 많은 네이티브 코드가 흩어지면 CPU가 코드 블록을 캐시에 유지하기 어렵게 되어, 실제 실행 속도가 느려진다
            - 즉, JVM 레벨 캐시는 커도 CPU 캐시는 작다
    - 메모리 사용량 증가 -> GC 및 OS 페이징 부담
        - Code Cache는 Native Memory를 사용하는데, 너무 크게 잡으면 다른 네이티브 메모리 영역(Metaspace, Thread Stack 등)과 충돌하거나 전체 시스템 메모리를 압박할 수 있다

한 줄 정리
- Code Cache가 가득 차면 JIT가 중단되고 인터프리터 모드로 되돌아가 성능이 저하됩니다. 하지만 Code Cache를 과도하게 늘리면 CPU I-Cache 비효율과 메모리 낭비로 오히려 성능이 떨어질 수 있습니다