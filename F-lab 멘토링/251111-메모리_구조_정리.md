## Heap

### “JVM의 메모리 구조에서 ‘Heap 영역’의 역할과 내부 구성 요소를 설명해주세요.”

나의 답변
- Heap은 자바에서 모든 객체와 배열이 실제로 저장되는 영역입니다. 힙 영역은 Young/Old 영역으로 나뉘는데 이때 Young 영역은 Eden과 Survivor (S0, S1)으로 나뉩니다. 객체 생성시 Eden에 생성되며 Young GC(Minor GC)에서 생존한 객체는 Survivor로 복사되어 옮겨집니다. threshold 이상의 GC에서 생존한 객체는 Old Generation으로 promotion 됩니다.

보완 요소
- 세대를 분리한 이유
    - 대부분의 객체는 금방 죽어서 Young 영역은 빠르게 자주 청소하고, Old 영역은 가끔 청소함으로써 전체 GC의 효율을 극대화 한다


### “Minor GC 도중 어떤 객체들은 Survivor로 가지 않고 ‘바로 Old로 승격(promotion)’됩니다. 이 ‘바로 승격’이 발생하는 대표 조건들을 모두 설명하고, 그로 인해 생길 수 있는 문제(예: promotion failure)와 이를 완화하기 위한 튜닝 포인트(대표 JVM 옵션들 포함)를 말해보세요.”

나의 답변
- 모르겠음

보완 요소
- 바로 Old로 promotion 되는 대표 조건
    1. 객체의 크기가 너무 커서 Young에 담지 못할 때
        - 대형 배열이나 거대한 객체는 Eden / Survivor에 한 번도 안들어가고 바로 Old로 가는데 이를 Pretenuring이라고 한다
        - JVM은 `-XX:PretenureSizeThreshold` 옵션으로 이 임계값을 조정할 수 있다 (단, Serial/Parallrl GC에서만 적용, G1에서는 무시됨)
    2. Survivor 공간이 부족할 때
        - Survivor의 S0/S1이 꽉 차면 남은 객체는 어쩔 수 없이 Old로 승격된다
        - 이를 Promotion failure라고 한다
        - 이때 Old 영역의 여유도 부족하면 Full GC(Minor GC)로 이어질 수 있다
    3. 객체의 Age가 임계값을 넘을 때
        - Survivor에 남아있는 객체는 Minor GC 때마다 age가 +1된다
        - 특정 age(기본 15, `-XX:maxTenuringThreshold`로 조정) 이상이 되면 Old로 승격된다
        - 하지만, 동적 기준(Adaptive Tenuring)이 적용되어 Survivor 내 비율에 따라 승격 시점이 자동으로 조정되기도 한다
    4. G1 GC의 경우
        - G1은 Region 단위로 관리하며, Eden/Survivor/Old가 논리적으로만 구분된다
        - Survivor 크기가 작거나 Region 회수가 적으면 promotion이 자주 일어나며, G1의 `Humongous Region` 정책에 따라 큰 객체는 바로 Old Region으로 들어간다

- 대표 튜닝 포인트

| 목적 | JVM 옵션 | 설명 |
| --- | --- | --- |
| 대형 객체를 바로 Old로 보낼 임계값 | `-XX:PretenureSizeThreshold=<bytes>` | Eden에 넣지 않고 바로 Old로 |
| 객체 승격 기준 age 조정 | `-XX:MaxTenuringThreshold=<n>` | 생존 횟수 조정 (기본 15) |
| Survivor 비율 조정 | `-XX:SurvivorRatio=<n>` | Eden:Survivor 비율 (기본 8:1:1) |
| Old 영역 크기 조정 | `-Xmx`, `-Xms`, `-XX:NewRatio` | 전체 및 세대별 메모리 비율 조절 |

- 한 줄 요약
    - **Eden에서 Old로 바로 가는 이유는 공간 부족, 객체 크기, 생존 횟수 초과 때문이며, 이 과정이 잦아지면 Promotion Failure -> Full GC로 이어질 수 있다**

### “Eden과 Survivor의 크기 비율(SurvivorRatio)을 잘못 조정하면 어떤 부작용이 생기며, GC 성능에는 어떤 영향을 주나요?”

나의 답변
- Survivor가 너무 작을 때는 공간이 부족해 Old로 바로 승격하는 경우가 발생할 수 있고 그에 따라 Old의 공간도 부족해져 Promotion Failure가 발생해 Full GC로 이어져 긴 STW로 인한 성능 저하가 발생할 수 있습니다. Survivor가 너무 클 경우엔 빈번한 Young GC로 인해 성능 저하가 발생할 수 있습니다.

보완 요소
- Survivor가 너무 크면 Eden 영역이 상대적으로 작아진다 (Young 전체 크기 = Eden + 2 * Survivor)
- Eden이 작으면 객체가 금방 차기 때문에 Minor GC 빈도가 증가해 성능 저하의 원인이 된다
- Survivor 비율 조정은 단순히 메모리 낭비 문제가 아니라, GC 주기와 객체 승격 패턴을 함께 바꾸기 때문에 GC 튜닝에서는 항상 Eden 크기와 함께 조합해 조정합니다

### “GC 로그를 통해 Survivor 공간이 너무 작거나 큰지를 어떻게 판단할 수 있을까요? 즉, GC 로그를 분석할 때 어떤 지표를 보면 Survivor 튜닝이 필요한지 설명해보세요.”

나의 답변
- Minor GC 로그에서 Eden/Survivor의 사용률, promotion 비율, 평균 생존 객체 비율을 확인합니다. Eden/Survivor 사용률에서 Eden의 사용률이 높다면 Survivor의 크기가 너무 작은것이고, 반대라면 크기가 너무 큰 것입니다. 또한 promotion 비율이 높거나 평균 생존 객체 비율이 높다면 Survivor의 크기가 작아 발생한 것이므로 Survivor의 크기를 키워 튜닝할 수 있습니다

보완 요소
- Eden 사용률이 높다고 해서 Survivor가 작다고 단정짓는건 위험하다
- 판단은 승격 바이트/비율, Survivor 포화 징후, tenuring 분포를 함께 봐야한다
    - 승격량(Promotion bytes) 추세가 높고 빈번한가?
        - Survivor 부족 / Old 압박
    - Survivor after-GC 사용률이 항상 상한 근처인가?
        - Survivor 부족
    - Eden이 너무 자주 비워짐(Young GC 빈도 증가) + Survivor가 한산
        - Survivor 과대 혹은 Eden 축소 가능성
    - age 분포 대비 threshold 에서 조기 승격이 많나?
        - `MaxTenuringThreshold` 재검토

---

## Stack

### “Stack 영역은 어떤 역할을 하며, ‘스레드마다 별도로 존재한다’는 말의 정확한 의미는 무엇인가요? 또한 `StackOverflowError`는 어떤 상황에서 발생하나요?”

나의 답변
- 스택 영역은 메서드가 실행될 때 임시로 필요한 메모리 공간을 제공하는 영역입니다. 스택오버플로우는 스택에 너무 많은 스택 프레임이 쌓여 공간이 부족해 더 이상 스택 프레임을 쌓을 수 없을 때 발생합니다.

보완 요소
- 스택 프레임은 로컬 변수 테이블, 오퍼랜드 스택, 프레임 데이터로 구성된 구조를 가지고 있어 JVM이 호출/리턴을 스택 기반으로 관리할 수 있습니다.
- JVM은 각 스레드마다 독립된 스택 영역을 생성합니다. 즉, 스레드 간 스택은 공유되지 않으며, 각자 자기만의 호출 스택을 가집니다. 이를 통해 스레드 안전성을 보장합니다.
- `StackOverFlowError`는 메서드가 너무 깊게 재귀 호출되거나, 무한 루프처럼 종료되지 않고 프레임이 계속 쌓일 때 발생합니다

### “스택에 저장된 데이터(지역 변수나 매개변수)는 GC의 대상이 되나요? 만약 GC가 스택 데이터를 건드리지 않는다면, 스택에서 참조 중인 객체는 어떻게 처리되나요?”

나의 답변
- 스택에 저장된 데이터는 GC의 대상이 되지 않습니다. GC는 Heap만 관리하기 때문입니다. 스택이 참조 중인 객체는 GC에서 살아남게 됩니다

보완 요소
- 스택이 참조 중인 객체는 Reachable 상태이므로 GC가 수거하지 않는다. GC Root에서 출발해 참조를 따라갈 수 있는 객체는 살아 있다고 간주한다
- 대표적인 GC Root는 다음과 같다
    - 스택 프레임 내의 지역 변수 / 매개변수 참조
    - 메서드 실행 중인 스레드의 레지스터
    - static 변수
    - JNI
- 즉, 스택의 참조 변수(객체)들은 GC Root로 간주되어 도달 가능한 상태이므로 GC의 수거 대상에서 제외된다

### “static 변수와 메서드 내부의 지역 변수는 둘 다 객체를 참조할 수 있습니다. 그렇다면 GC 관점에서 두 변수의 차이는 무엇인가요?”

나의 답변
- 메서드 내부의 지역 변수는 메서드 수행이 끝나면 참조가 끊어져 GC의 수거 대상이 되지만, static 변수는 자바 프로그램이 종료될 때까지 살아있기 때문에 참조가 지속되어 GC의 수거 대상이 되지 않습니다

보완 요소
- static 변수는 Metaspace에 저장됩니다. 이는 객체가 아닌 클래스 자체에 속함을 의미하는데, static 변수의 객체 참조는 클래스가 JVM에 로드될 때 초기화되고, 해당 클래스 로더가 언로드되기 전까지 유지되어 GC Root로 간주되어 참조가 유지되는 한 해당 객체는 GC가 회수하지 않습니다

### “static 변수가 메모리 누수를 일으킬 수 있다는 말은 무슨 뜻인가요? 그리고 실제로 어떤 상황에서 static 변수가 GC를 방해하는지 예시를 들어 설명해주세요.”

나의 답변
- static 변수는 클래스 로더가 유지되는 한 GC의 대상이 되지 않습니다. 따라서, 사용되고 있지 않더라도 메모리를 차지하고 있어 메모리 누수를 일으킵니다. 예를 들어 static으로 List나 Map에 지속적으로 객체를 추가하고 제거하지 않으면 많은 객체의 참조가 유지되어 GC Root로 간주되어 GC의 대상이 되지 않아 메모리 누수를 일으키는 원인이 됩니다.

보완 요소
- 자바에서 메모리 누수는 더 이상 사용되지 않지만, GC가 수거할 수 없는 객체가 존재하는 상황을 말한다
- 즉, 도달성(reachability)은 있지만 의미상 사용되지 않는 객체이다
- 이를 방지하기 위해선 static 컬렉션 사용 시 명시적 clear() 호출을 하거나, WeakReference/WeakHashMap을 사용해 GC에 회수될 수 있도록 구성하거나, 필요 시 클래스 로더 언로드를 통해 static 메모리를 해제하면 됩니다

---

## Metaspace

### “Metaspace는 어떤 역할을 하는 영역인가요? 그리고 Java 8 이전의 PermGen(Permanent Generation)과 비교했을 때 어떤 차이가 있나요?”

나의 답변
- Metaspace는 클래스의 메타데이터가 저장되는 영역으로, JVM이 로딩한 클래스의 정보가 저장되는 공간입니다. PermGen은 크기가 고정되어 OutOfMemery가 자주 발생하고, 클래스가 언로드 돼도 내부 메모리를 GC가 잘 수거하지 못했고, 힙 영역에 있었기 때문에 OS의 네이티브 메모리와 연동이 비효율적이었다. Metaspace는 크기를 자동으로 확장할 수 있고, 클래스 언로드시 GC가 잘 수거할 수 있었으며, 네이티브 메모리 영역에 있습니다

### “Metaspace는 네이티브 메모리를 사용해 자동으로 확장된다고 했습니다. 그렇다면 왜 여전히 `OutOfMemoryError: Metaspace`가 발생할 수 있을까요? 그리고 실제로 어떤 상황에서 이런 문제가 자주 발생하나요?”

나의 답변
- 물리적으로 OS 메모리가 부족할 때 발생할 수 있습니다.

보완 요소
- JVM 옵션으로 최대 크기를 설정한 경우와 물리적 OS 메모리가 부족할 경우 발생할 수 있다
- 실무에서 자주 발생하는 상황
    - 클래스 로더 누수 (ClassLoader Leak)
        - WepApp 재배포 시, 클래스 로더가 해제되지 않고 새로 로드됨
        - 과거 클래스 정보들이 계속 남아 Metaspace에 쌓임
        - 대표적으로 Tomcat, WebLogic, Spring Boot DevTools 재시작 시 자주 발생
    - 무한한 동적 클래스 생성
        - 예 : 프록시, 리플렉션, 바이트코드 조작 도구
            - Hibernate, Spring CGLIB Proxy, Javassist, Groovy, ASM 등
        - 지속적으로 새로운 클래스를 JVM에 로딩하면 Metaspace가 끝없이 커짐
    - 오랫동안 해제되지 않는 ClassLoader 보유 객체
        - 예 : static Map에 ClassLoader를 참조하는 경우
        - GC는 ClassLoader 단위로 Metaspace를 해제하므로, 참조가 남으면 메모리 누수가 발생

한 줄 정리
- Metaspace는 OS 네이티브 메모리를 사용하므로 물리적으로 무한하지 않으며, ClassLoader 누수나 동적 클래스 로딩이 누적될 때 OutOfMemoryError가 발생한다

### “GC는 언제 Metaspace를 청소하나요? 즉, 클래스 언로드(Class Unloading)는 어떤 조건에서 발생하나요?”

나의 답변
- 모르겠음

보완 요소
- GC는 클래스 언로드가 가능한 경우에만 Metaspace의 메모리를 해제한다
- 모든 GC마다 자동으로 언로드 되는것이 아닌, 클래스 로더와 연결된 클래스들이 더 이상 참조되지 않을 때만 언로드됩니다
- 클래스 언로드 조건
    - ClassLoader 객체가 더 이상 참조되지 않을 것
        - Heap 어딘가에서 해당 로더를 참조하는 변수가 없어야 함
    - 그 로더가 로드한 클래스들도 더 이상 참조되지 않을 것
        - Heap의 어떤 객체도 해당 클래스의 타입으로 존재하지 않아야 함
    - GC가 Full GC(또는 Concurrent Class Unloading 지원시, Major GC) 수행 중일 것

한 줄 정리
- 클래스 언로드는 GC 시점이 아니라, ClassLoader가 참조 해제될 때 발생하며, 그때 Metaspace에 저장된 클래스 메타데이터가 청소된다.

---

## Native Method Stack

### “Native Method Stack은 어떤 역할을 하는 영역인가요? 그리고 일반적인 Stack 영역과 어떤 차이가 있나요?”

나의 답변
- 네이티브 메서드를 실행할 때 사용하는 스택 영역입니다. 네이티브 메서드는 JNI를 통해 사용할 수 있는데 네이티브 메서드 호출 시 자바 스택에서 네이티브 스택으로 제어를 넘기고, 마치면 다시 자바 스택으로 돌아갑니다

보완 요소
- 자바 스택과의 차이점

| 구분         | Java Stack             | Native Method Stack                        |
| ---------- | ---------------------- | ------------------------------------------ |
| **용도**     | 자바 메서드 실행용             | 네이티브 메서드 실행용                               |
| **언어**     | Java 바이트코드             | C, C++ 등의 네이티브 코드                          |
| **생성 주체**  | JVM이 스레드 생성 시 함께 생성    | JVM이 네이티브 호출 시 생성                          |
| **GC 연관성** | GC Root에 포함 (참조 추적 가능) | GC와 직접 관련 없음 (단, JNI 참조는 Root로 인식됨)        |
| **예외 종류**  | `StackOverflowError`   | `StackOverflowError` 또는 `OutOfMemoryError` |

한 줄 정리
- Native Method Stack을 JNI를 통해 C/C++ 네이티브 코드를 실행할 때 사용하는 별도 스택으로, 자바 스택과는 독립적으로 존재하지만 스레드 단위로 함께 관리된다

### “JVM에서 Java Stack과 Native Method Stack은 물리적으로 완전히 분리된 영역일까요? 아니면 구현체(예: HotSpot JVM)에서는 통합되어 있을까요?”

나의 답변
- 모르겠습니다

보완 요소
- 스펙 관점
    - JVM 명세에 따르면 둘은 별개의 영역으로 정의되어 있다고 한다
    - 이유는 JVM 구현체마다 네이티브 코드를 실행하는 방식이 다르기 때문이다
- 실제 HopSpot JVM 구현
    - HopSpot JVM에서는 두 스택이 물리적으로 통합되어 있다
    - 즉 자바 스택과 네이티브 스택은 동일한 OS 스레드 스택을 공유한다
    - 따라서 JNI 호출이 일어나도, 단순히 같은 스택 위에서 네이티브 코드로 제어가 넘어가는 형태로 동작한다
    - 이유
        - HotSpot JVM은 자바 스레드와 OS 스레드가 1:1로 매핑된다
        - OS 스레드 자체가 이미 스택을 가지고 있기 때문에, 굳이 둘로 나눌 필요가 없다
        - 따라서 네이티브 메서드 실행 시 동일한 스택 프레임 상에서 JNI 코드가 수행된다

한 줄 정리
- JVM 스펙상으로는 자바 스택과 네이티브 스택은 별도지만, HotSpot 같은 실제 구현에서는 하나의 통합된 OS 스레드 스택으로 관리된다

### “StackOverflowError와 OutOfMemoryError: unable to create new native thread는 둘 다 스택 관련 에러처럼 보입니다. 하지만 이 둘은 근본적으로 어떤 차이가 있나요?”

나의 답변
- 모르겠습니다

보완 요소
- StackOverflowError
    - 이미 존재하는 스레드의 스택이 넘친 상황
    - 발생 조건
        - 하나의 스레드 내부에서 스택 프레임이 너무 깊게 쌓여 해당 스레드의 스택 크기 한도를 초과한 경우 발생
    - 주 원인
        - 깊은 재귀 호출
        - 메서드 호출이 너무 중첩되어 스택 프레임이 누적
- OutOfMemoryError: unable to create new native thread
    - 새 스레드를 만들 수 없는 상황
    - 발생 조건
        - 새로운 스레드를 생성하려 할 때 운영체제가 해당 스레드용 스택 공간을 더 이상 할당할 수 없을 때 발생
    주 원인
        - 스레드 수 과도
        - OS 레벨 스레드 한계 초과
        - 전체 시스템 메모리 부족으로 스택 공간 확보 실패

한 줄 정리
- StackOverflowError는 하나의 스레드 안에서 스택이 넘친 경우, OutOfMemoryError: unable to create new native thread는 새 스레드를 만들 수 없을 경우 발생합니다

---

## PC Register

### “JVM의 PC Register는 어떤 역할을 하는 영역인가요? 그리고 스레드마다 별도로 존재한다는 말은 무슨 의미인가요?”

나의 답변
- 현재 실행중인 명령어의 위치를 저장하는 공간이다. 스레드마다 별도로 존재하는 이유는 지금 이 스레드가 자바 바이트코드 어디를 실행중인지 알아야 하기 때문입니다.

보완 요소
- JVM이 실행 중인 바이트코드 명령어의 주소(라인 번호)를 저장하는 공간
- JVM은 멀티스레드 환경에서 각 스레드가 동시에 다른 메서드를 실행할 수 있기 때문에, 스레드마다 어디까지 실행했는지를 별도로 추적해야 한다
- 네이티브 메서드는 자바 바이트코드를 실행하지 않기 때문에, 해당 스레드의 PC Register는 undefined 상태 또는 0으로 둔다

### “JVM은 PC Register를 통해 현재 실행 중인 바이트코드의 위치를 추적합니다. 그런데 JIT 컴파일이 적용되어 바이트코드가 네이티브 코드로 변환된 경우, JVM은 실행 위치를 어떻게 추적하나요?”

나의 답변
- 모르겠습니다

보완 요소
- JIT 컴파일이 활성화되면, 바이트코드 일부가 머신 코드(네이티브 코드)로 변한되어 CPU에서 직접 실행된다
- 이때는 바이트코드 주소가 아닌 CPU 명령어 주소를 기준으로 실행된다
- JIT 후에 PC Register는 어떻게 동작하나?
    - JIT 컴파일된 코드는 CPU 레벨의 레지스터(하드웨어 PC)를 사용한다
    - 즉, JVM의 논리적 PC Register는 더 이상 명령어 포인터 역할을 수행하지 않는다
    - 대신 JVM 내부에서는 바이트코드 <-> 네이티브 코드 주소 매핑 테이블을 유지한다
- 동작 과정
    1. 바이트코드 실행 중 JIT 트리거 발생
    2. JIT 컴파일러는 BCI와 네이티브 코드의 싲가 주소를 매핑해 내부 테이블에 기록한다
    3. JVM은 JIT 코드 실행 중에도 예외 처리, 디버깅, 스택 트레이스 등을 위해 BCI를 역으로 계산할 수 있다
    4. 즉, PC Register는 논리적으로 존재하지만, 실제 주소는 매핑 테이블을 통해 간접적으로 추적된다

한 줄 정리
- JIT 컴파일 되어도 JVM 은 바이트코드와 네이티브 코드의 주소 매핑 정보를 유지합니다. 따라서 실제 실행은 CPU의 물리적 PC Register가 담당하지만, JVM은 내부 테이블을 통해 논리적 바이트코드 PC를 추적할 수 있다