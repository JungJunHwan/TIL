# 상속과 조합

## 상속(Inheritance)

- "A는 B이다(A is a B)" 관계일 때 사용
- 부모 클래스의 속성과 기능을 그대로 물려받아 확장하는 것
- 예시)

```java
class Animal {
    void eat() { System.out.println("먹는다"); }
}

class Dog extends Animal {
    void bark() { System.out.println("멍멍"); }
}
```

- Dog는 Animal의 기능을 그대로 상속받음
- Dog 객체는 eat()과 bark() 모두 사용 가능

### 장단점

- 장점
    - 코드 재사용 쉬움
    - 공통 기능을 부모에 넣어 깔끔하게 유지 가능
- 단점
    - 부모 클래스 변경이 자식 클래스에 영향 -> **결합도 증가**
    - 상속 구조가 깊어지면 유지보수가 어려움
    - 필요 이상으로 부모 기능을 다 가져와야 함 -> 강제 의존

## 조합(Composition)

- "A는 B를 가진다(A has a B)" 관계일 때 사용
- 클래스 안에 다른 객체를 필드로 포함시켜 기능을 사용하는 방식
- 기능을 유연하게 붙였다 떼었다 하고 싶을 때, 여러 기능을 조립해 객체를 만들고 싶을 때 사용
- 예시)

```java
class Engine {
    void run() { System.out.println("엔진 가동"); }
}

class Car {
    private Engine engine = new Engine();

    void drive() {
        engine.run();
        System.out.println("주행");
    }
}
```

- Car는 Engine을 가지고 있음
- 필요한 기능만 맞춤 조합해서 사용 가능

### 장단점

- 장점
    - 상속보다 느슨한 결합
    - 언제든지 내부 객체를 교체하거나 확장하기 쉬움
    - 불필요한 기능을 강제로 상속받지 않음
    - 유지보수 쉬움

- 단점
    - 코드가 더 길어질 수 있음
    - 호출이 한 단계 늘어남

## 꼬리물기 질문

### 상속과 조합의 가장 큰 차이를 설명하라

- 상속은 is-a 관계로, 부모의 기능을 그대로 이어받기 때문에 코드 재사용이 쉽지만 부모 변경 시 자식이 바로 영향을 받는 단단한 결합 구조이다. 반면 조합은 has-a 관계로, 필요한 객체를 내부에 포함하여 사용하는 방식이라 원하는 기능만 선택적으로 사용할 수 있으며 훨씬 느슨한 결합을 제공한다.

### 조합이 더 권장되는 이유는 무엇인가

조합이 더 좋은 이유는 단순히 결합도가 낮아서가 아닌 객체지향 설계 원칙(SOLID)을 훨씬 잘 지키기 때문이다

1. 단일 책임 원칙 (SRP) - 상속은 책임이 새어나간다
    - 상속을 하면 부모가 하는 일 + 자식이 하는 일 = 하나의 객체에서 섞임
        - 예) Car extends Vehicle -> 부모 Vehicle이 수정되면 Car도 동작이 바뀐다
    - 반면 조합은 객체가 자신의 책임만 가진다
        - 예) Car has an Engine -> Engine의 책임과 Car의 책임이 명확히 분리된다
2. 개방-폐쇄 원칙 (OCP) - 상속은 구조가 너무 단단하다
    - 상속 구조는 한 번 만들면 바꾸기 어렵다
        - A -> B -> C 구조로 상속받고 있다면, 하나 수정하면 연쇄적으로 깨질 수 있다
    - 반면 조합은 내부 객체만 바꿔끼우면 된다
3. 리스코프 치환 원칙 (LSP) - 상속은 종종 LSP를 깨버린다
    - LSP는 부모 타입 자리에 자식 타입이 와도 정상 동작해야 한다는 원칙인데 상속은 이를 자주 깨뜨린다
    - 반면 조합은 객체를 조합하지 않으면 되므로 이런 문제가 없다