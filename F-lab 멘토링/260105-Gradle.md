# Gradle

Gradle은 빌드 자도오하 도구로, Groovy나 Kotlin DSL(Domain Specific Language)을 사용하여 빌드 로직을 작성한다

<br>

XML 기반의 Ant, Maven과 달리, 코드로 빌드 과정을 제어할 수 있어 유연성이 높다

## Gradle 스크립트의 구성 요소

일반적인 `build.gradle` 파일은 여러개의 Script Block으로 구성된다

### `plugins`

Gradle의 기능을 확장하는 모듈을 선언

- 역할
    - Task 추가
        - `compileJava`, `test`, `jar` 같은 작업 단위를 생성
    - Domain Object 추가
        - `sourceSets`, `dependencies` 같은 설정 블록을 사용할 수 있게 함
    - Convention 설정
        - "자바 소스 코드는 `src/main/java`에 있어야 한다"와 같은 표준 경로를 지정
- 예시
    - ```groovy
        plugins {
            id 'java'   // 1. 코어 플러그인
            id 'com.github.johnrengelman.shadow' version '8.1.1'    // 2. 커뮤니티 플러그인
            id 'org.springframework.boot' version '3.2.0' apply false   // 3. 스프링 부트 플러그인
        }
    ```
    - 코어 플러그인 (Core Plugins)
        - Gradle 배포판에 이미 포함된 플러그인
        - 별도의 버전을 명시하지 않으며, Gradle 버전에 맞춰진 플러그인이 자동으로 사용
        - 예시: `java`, `groovy`, `kotlin-dsl`, `war`, `maven-publish`, `checkstyle`
    - 커뮤니티 플러그인 (Community Plugins)
        - 외부 개발자나 기업(Spring, Google 등)에서 만든 플러그인
        - 반드시 버전을 명시해야하며, Gradle Plugin Portal에서 다운로드됨
        - 예시: `org.springframework.boot`, `io.spring.dependency-management`
    - `apply false`의 의미
        - 멀트 프로젝트 빌드에서 주로 사용됨
        - 플러그인을 루트 프로젝트에서 찾아서 로드는 해두되, 현재 프로젝트에 바로 적용하지는 않는다는 뜻
        - 루트에서 버전을 관리하고, 실제 필요한 서브 프로젝트에서 버전 없이 `id`만 선언하여 사용할 때 씀

<br>

플러그인 적용의 내부 동작 (Resolution)

- Gradle이 `plugins` 블록을 만나면 내부적으로 다음과 같은 과정을 거침
    1. Resolve
        - 설정된 `id`와 `version`을 바탕으로 해당 플로그인 바이너리(Jar 파일)가 어디 있는지 찾는다 (로컬 캐시 혹은 플러그인 포털)
    2. Classload
        - 찾은 플러그인 클래스들을 빌드 스크립트의 Classpath에 올린다
    3. Apply
        - 플러그인의 `apply(Project project)` 메소드를 실행하여 프로젝트에 Task와 설정을 주입

### `repositories`

프로젝트에서 사용할 라이브러리(의존성)를 어디서 다운로드할지 지정

- `mavenCentral()`
    - 전 세계에서 가장 많이 사용되는 공개 저장소
- `google()`
    - 안드로이드 관련 라이브러리가 저장된 저장소
- `mavenLocal()`
    - 내 로컬 PC에 저장된 라이브러리를 사용

<br>

저장소 검색 우선순위 (Resolution Strategy)

- 블록에 선언된 순서대로 검색함

```groovy
repositories {
    google()    // 1순위 검색
    mavenCentral()  // 2순위 검색
}
```

### `dependencies`

프로젝트에서 사용할 외부 라이브러리와 모듈 간의 의존성을 정의하는 곳. 단순히 어떤 라이브러리를 사용할 것인지가 아닌, 그 라이브러리를 언제/어디서 사용할지를 결정함

- `implementation`
    - 해당 라이브러리를 현재 모듈의 내부에서만 사용
    - 이 모듈을 의존하는 상위 모듈에서는 이 라이브러리에 접근할 수 없음
    - 이를 통해 캡슐화를 지키고, 라이브러리 변경 시 상위 모듈을 다시 컴파일할 필요가 없어 빌드 속도가 빠름
- `api`
    - 해당 라이브러리를 현재 모듈뿐만 아니라, 이 모듈을 의존한느 다른 모듈에게도 노출
    - `java-library` 플러그인을 사용해야 사용 가능
    - 공통 모듈을 만들 때, 그 모듈을 사용하는 곳에서도 해당 라이브러리를 직접 써야 하는 경우에만 제한적으로 사용
- `compileOnly`
    - 컴파일 시점에는 필요하지만, 실행 시점에는 포함되지 않는 의존성
    - 예시) 롬복은 컴파일 시점에 코드를 생성해주기만 하면 되고 결과물인 JAR에는 포함될 필요가 없음
- `runtimeOnly`
    - 컴파일 시에는 필요 없으나, 실행시에 필요한 라이브러리
    - DB 드라이버가 대표적인데, 코드상에서는 JDBC인터페이스를 사용하지만, 실제 연결 시에는 드라이버 파일이 필요하기 때문
- `testImplementation`
    - 테스트 코드를 실행할 때만 필요한 라이브러리
    - JUnit, AssertJ, Mockito 등, 실제 배포되는 제품 코드에는 포함되지 않음
- `annotationProcessor`
    - 어노테이션을 해석해서 코드를 생성하는 라이브러리를 지정
    - Lombok, Querydsl, MapStruct 등을 사용할 때 필수적으로 지정해야 함

#### 의존성 선언 방식

1. 외부 원격 저장소 라이브러리
    - 가장 일반적인 형태이며 `그룹ID:이름:버전` 순서로 작성
    - ```groovy
        dependencies {
            implementation 'org.springframework.boot:spring-boot-starter-web:3.2.0'
        }
        ```
2. 로컬 프로젝트 의존성 (멀티 프로젝트)
    - 내 프로젝트 안의 다른 모듈을 가져올 때 사용
    - ```groovy
        dependencies {
            implementation project(':common-module')
        }
        ```
3. 로컬 파일 의존성
    - 저장소에 없는 특정 JAR 파일을 직접 가져올 때 사용
    - ```groovy
        dependencies {
            implementation files('libs/my-custom-lib.jar')
            implementation fileTree(dir: 'libs', include: ['*.jar']) // 폴더 내 모든 jar 포함
        }
        ```

#### 의존성 전이 (Transitive Dependencies)

Gradle은 내가 A라는 라이브러리를 추가했을 때, A가 내부적으로 사용하는 B, C 라이브러리도 자동으로 다운로드 해주는데 이를 의존성 전이라 한다

- 특정 라이브러리를 제외하고 싶을 때 다음과 같이 작성
    - ```groovy
        dependencies {
            implementation('org.hibernate:hibernate-core:5.6.0.Final') {
                exclude group: 'org.javassist', module: 'javassist' // 특정 의존성 제외
            }
        }
        ```

### `tasks`

Gradle의 작업 최소 단위. 개발자가 직접 정의하거나 기존 태스크를 수정할 수 있음

- 단순한 실행할 코드의 덩이락 아니라, 액션(Action), 입력(Input), 출력(Output)을 가진 객체
    - Actions
        - Task가 실행될 때 수행할 작업 목록 (예: 파일 복사, 명령 실행)
    - Inputs
        - 작업을 수행하기 위해 필요한 파일이나 설정값
    - Outputs
        - 작업을 수행한 결과물 (예: 생성된 `.class`, `.jar` 파일)

#### 구성(Configuration)과 실행(Execution)

Task 내부에 코드를 짤 때 위치에 따라 실행 시점이 완전히 다름

- Task 블록 내부에 직접 쓴 코드는 해당 Task를 실행하지 않더라도(예: `./gradle help`) 무조건 실행되므로, 실제 로직은 반드시 `doFirst`나 `doLast`에 넣어야 한다

```groovy
tasks.register('lifecycleDemo') {
    // 1. 구성 단계에서 실행 (빌드가 시작되자마자 출력됨)
    println 'Configuration phase: I always run!'

    doFirst {
        // 2. 실행 단계의 가장 앞부분 (Task가 실행될 때만 출력)
        println 'Execution phase: doFirst'
    }

    doLast {
        // 3. 실행 단계의 가장 마지막 (Task가 실행될 때만 출력)
        println 'Execution phase: doLast'
    }
}
```

#### Task 간의 관계 설정 (Task Graph)

Task들은 서로 의존하거나 순서를 가질 수 있는데, 이를 통해 Gradle은 거대한 DAG (Directed Acyclic Graph)를 그린다

- `dependsOn` (의존성)
    - A가 B에 의존하면, A를 실행할 때 B가 먼저 실행됨
    - ```groovy
        tasks.register('taskA') { doLast { println 'A' } }
        tasks.register('taskB') {
            dependsOn 'taskA'
            doLast { println 'B' }
        }
        // ./gradlew taskB 실행 시 A 출력 후 B 출력
        ```
- `mustRunAfter` (순서 지정)
    - 의존성은 없지만, 두 Task가 모두 실행될 경우 순서를 강제
- `finalizedBy` (사후 작업)
    - 특정 Task가 끝난 후 항상 실행될 Task를 지정 (예: 테스트 후 리포트 생성)

#### 증분 빌드 (Incremental Build)

Gradle이 다른 도구보다 빠른 이유는 이미 한 작업은 다시 하지 않기 때문이다. Task의 `inputs`와 `outputs`를 정의하면, Gradle을 파일이 바뀌지 않았을 경우 실행을 건너뛰고 `UP-TO-DATE` 표시를 띄운다

```groovy
tasks.register('processFile') {
    inputs.file 'src/data.txt'      // 입력 파일
    outputs.file 'build/output.txt' // 출력 파일
    
    doLast {
        // 실제 처리 로직
    }
}
```

## Gradle의 빌드 생명주기 (Build Lifecycle)

Gradle은 스크립트를 단순히 위에서 아래로 실행하는 것이 아니라, 세 단계를 거쳐 동작한다

1. 초기화 (Initialization)
    - `settings.gradle` 파일을 읽는다
    - 단일/멀티 프로젝트인지 확인하고 어떤 프로젝트들이 빌드에 참여할지 결정
2. 구성 (Configuration)
    - 참여하는 모든 프로젝트의 `build.gradle` 파일을 실행한다
    - 이 단계에서 태스크 내의 코드가 아닌, 태스크 외부의 코드들이 실행되어 "태스크 그래프"를 그린다
3. 실행 (Execution)
    - 명령어(예: `./gradlew build`)로 요청한 특정 태스크와 그 태스크가 의존하는 다른 태스크들을 실제 순서대로 실행

## 핵심 파일

### settings.gradle

프로젝트의 구조를 정의하는 파일

- 프로젝트의 이름을 설정 (`rootProject.name = 'my-project'`)
- 멀티 모듈 프로젝트에서 포함될 하위 모듈들을 지정 (`include 'api', 'core', 'common'`)

### Gradle Wrapper (`gradlew`, `gradle.bat`)

Gradle을 설치하지 않은 환경에서도 빌드를 가능하게 해주는 셸 스크립트
- 모든 팀원이 동일한 버전의 Gradle을 사용하도록 강제하여 내 컴퓨터에선 되는데 다른 컴퓨터에서 안되는 문제를 방지
- `gradle-wrapper.properties` 파일에 정의된 버전을 자동으로 다운로드하여 실행

## 멀티 프로젝트 빌드

여러 개의 모듈을 관리해야 할 때는 `subprojects`나 `allprojects` 블록을 사용

- `allprojects`
    - 루트 프로젝트를 포함한 모든 모듈에 공통으로 적용할 설정
- `subprojects`
    - 하위 모듈들에만 공통으로 적용할 설정

```groovy
// 루트 build.gradle 예시
subprojects {
    apply plugin: 'java'
    repositories {
        mavenCentral()
    }
    dependencies {
        testImplementation 'org.junit.jupiter:junit-jupiter:5.10.0'
    }
}
```

### 멀티 프로젝트 파일 설정 예시

#### 프로젝트 구조

```text
my-application/
├── settings.gradle          <-- 프로젝트 구성 정의
├── build.gradle             <-- 루트 프로젝트 설정 (공통 설정)
├── core/
│   └── build.gradle         <-- core 모듈 설정
├── api/
│   └── build.gradle         <-- api 모듈 설정
└── util/
    └── build.gradle         <-- util 모듈 설정
```

#### `settings.gradle`

루트 프로젝트의 `settings.gradle`에서 어떤 하위 프로젝트들을 포함할지 명시해야 함

```groovy
rootProject.name = 'my-application'

// 하위 모듈 포함
include 'core'
include 'api'
include 'util'
```

#### 루트 `build.gradle` (`allprojects`, `subprojects`)

여기서 프로젝트 전체에 대한 설정을 관리한다

```groovy
// 1. 모든 프로젝트(루트 포함)에 공통으로 적용
allprojects {
    group = 'com.example'
    version = '1.0.0-SNAPSHOT'

    repositories {
        mavenCentral()
    }
}

// 2. 하위 모듈들에만 적용되는 설정
subprojects {
    apply plugin: 'java'    // 모든 서브 모듈에 자바 플러그인 적용
    apply plugin: 'java-lebrary'

    sourceCompatibility = '17'
    targetCompatibility = '17'

    dependencies {
        // 모든 서브 모듈에서 공통으로 쓰는 라이브러리
        testImplementation 'org.junit.jupiter:junit-jupiter:5.10.0'
        compileOnly 'org.projectlombok:lombok:1.18.30'
        annotationProcessor 'org.projectlombok:lombok:1.18.30'
    }

    // 모든 서브 모듈에 공통 태스크 추가
    tasks.withType(JavaCompile) {
        options.encoding = 'UTF-8'
    }
}
```

#### 하위 모듈별 `build.gradle`

1. `core/build.gradle`

```groovy
dependencies {
    // core 모듈에만 필요한 라이브러리
    api 'org.apache.commons:commons-lang3:3.12.0' 
}
```

2. `api/build.gradle`

```groovy
dependencies {
    // 1. 같은 프로젝트 내의 다른 모듈(core)을 의존성으로 추가 (가장 중요!)
    implementation project(':core') // ':'은 프로젝트 경로를 구분하는 구분자 (/, \와 같은 원리)
    implementation project(':util')

    // 2. api 모듈에만 필요한 라이브러리 (Spring Boot 등)
    implementation 'org.springframework.boot:spring-boot-starter-web'
}
```