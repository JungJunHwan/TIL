# GC (Garbage Collection)

## GC란?

- GC는 더 이상 사용되지 않는 객체(참조가 끊긴 객체)를 자동으로 메모리에서 해제해주는 JVM의 메모리 관리 기능이다

## GC의 종류

| GC 종류 | 특징 |
| :-- | :-- |
| Serial GC | 단일 스레드, 단순하지만 느림 (Client JVM 기본) |
| Parallel GC | 여러 스레드로 병렬 처리 (서버용 기본) |
| CMS (Concurrent Mark Sweep) | STW 최소화, 자바 9부터 deprecated |
| G1 GC | 자바 9 이후 기본 GC. Region 단위 관리 |
| ZGC / Shenandoah GC | 최신 저지연 GC, STW 시간 매우 짧음 |

## GC 동작 과정

- GC는 단순히 삭제가 아닌 3단계로 이뤄진다
    1. Mark (표시)
        - 살아있는 객체를 탐색하고 표시 (루트부터 도달 가능한 객체만)
    2. Sweep (제거)
        - 표시되지 않은 객체(참조가 끊긴 것)를 메모리에서 삭제
    3. Compact (압축)
        - 메모리 파편화를 방지하기 위해 살아있는 객체들을 한쪽으로 모음

## STW (Stop The World)

- GC가 실행될 때, 애플리 케이션 스레드를 일시 정지시키는 현상
- 모든 스레드가 멈추고 GC 스레드만 실행된다

## G1 GC (Garbage First GC)

- 가장 쓰레기가 많은 영역부터 우선 정리하는 GC
- 각 Region마다 Garbage 비율과 회수 효율(Recovery Cost)을 계산해, 가장 효율이 높은 Region부터 청소한다

### 기본 구조 : Region 기반 힙 구조

- 기존 GC는 힙을 고정된 Young/Old 영역으로 나눴지만, G1은 전체 힙을 동일한 크기의 작은 블록(Region)으로 잘라서 관리한다
- 예를 들어, 힙 전체가 8GB라면, 보통 하나의 Region은 1~32MB 크기다 (JVM이 자동 결정)

- Region의 역할

| Region 종류 | 역할 |
| :-- | :-- |
| Eden Region | 새로 생성된 객체가 들어감 |
| Survivor Region | Young GC에서 살아남은 객체 저장 |
| Old Region | 장수 객체 저장 |
| Humongous Region | 매우 큰 객체(Region 크기의 50% 이상)가 들어감 |

- 즉, Region은 물리적으로 같지만, 논리적으로 역할이 계속 바뀌는 구조이다

### G1 GC의 동작 주기

1. Young GC (Minor GC)
    - Eden이 가득 차면 발생
    - 살아있는 객체를 Survivor -> Old로 이동
    - STW 발생 (짧음)
2. Concurrent Marking (동시 마킹)
    - Old 영역의 객체 중 살아있는 객체를 백그라운드에서 탐색
    - 애플리케이션 스레드와 동시에 실행 가능 (동시성 보장)
3. Mixed GC
    - 마킹 결과를 기반으로 Garbage 비율이 높은 Old Region을 선별
    - Young + 일부 Old를 함께 청소
    - STW 발생하지만 짧게 유지

### G1의 주요 알고리즘 단계

| 단계 | 설명 | STW 여부 |
| :-- | :-- | :-- |
| Initial Mark | 루트에서 접근 가능한 객체 마킹 시작 | STW |
| Concurrent Mark | 백그라운드로 살아있는 객체 탐색 | X (병렬 실행) |
| Remark | 새로 생성된 객체 다시 확인 | STW |
| Cleanup | 사용하지 않는 Region 정리 | STW |
| Mixed GC | 살아있는 객체를 새 Region으로 복사 | STW |

- Mixed GC 과정
    1. 컬렉션 셋(Collection Set, CSet) 구성
        - 매 pause마다 다음을 묶어 CSet을 만든다
            - Young : Eden + Survivor
            - Old(선택) : Concurrent Marking 결과 가비지 비율이 높은 리전 일부만
        - CSet은 목표 정지 시간에 맞춰 예측 모델로 제한된다 -> 여러 pause로 나눔
    2. Remembered Set(RSet) 이용
        - G1은 리전 간 참조를 RSet에 유지한다
        - CSet에 포함된 Old 리전을 수거할 때 외부의 다른 리전에서 들어오는 참조만 빠르게 확인해 살아있는 객체를 판별/복사한다
    3. Evacuation 방식
        - CSet 안의 살아있는 객체를 새 Eden,Survivor,Old 리전으로 복사하며, 원래 리전은 지웁니다 -> 자동 Compaction 효과
        - 포인터는 forwarding으로 재설정, RSet 갱신
    4. Humongous 리전 처리
        - 거대 객체(리전 크기의 50% 이상)는 전용 리전에 들어가며, Mixed 단계나 Cleanup에서 연속 리전 묶음 단위로 회수 후보가 된다
- 다음 중 하나를 만족하면 Mixed GC 종료
    - 회수 가치 높은 Old 리전이 목표 수 이하로 줄음
    - Mixed GC 목표 횟수를 채움
    - 예상 정지 시간을 맞추려면 더 이상 Old를 섞지 않는게 유리하다고 판단

### Region 기반 Compaction

- 기존 GC의 단점 중 하나는 Full GC 시 전체 힙을 압축해야 한다는 점이었는데, 이는 오래 걸리고 STW가 길었다
- G1은 Region 단위로 동작하기 때문에, 필요한 Region만 복사하면서 자동으로 Compact가 같이 수행된다
- 즉, 파편화가 거의 생기지 않는다

### G1 GC의 장단점

- 장점
    - STW 감소 : 전체가 아닌 일부 Region만 수집하므로 짧은 일시정지
    - 예측 가능한 Pause Time : `-XX:MaxGCPauseMillis=200` 등으로 목표 시간 지정 가능
    - 자동 Compaction : 별도의 압축 단계 없이 Region 이동 시 자동 정리
    - 대용량 Heap 적합 : 수~수십 GB Heap에서도 효율적으로 동작
    - 동시성 : Concurrent Mark 단계에서 앱과 병행 실행 가능
- 단점
    - 오버헤드 : Region 관리 메타데이터가 많아짐
    - 작은 힙엔 비효율적 : 수백 MB 단위의 작은 힙에서는 Parallel GC가 더 빠름
    - 튜닝 복잡 : Young/Old 비율 자동 조정이라 완전한 제어가 어려움

### 주요 JVM 옵션

| 옵션                         | 설명                   |
| -------------------------- | -------------------- |
| `-XX:+UseG1GC`             | G1 GC 활성화            |
| `-XX:MaxGCPauseMillis=200` | 목표 일시정지 시간 (ms 단위)   |
| `-XX:G1HeapRegionSize=16m` | Region 크기 설정 (기본 자동) |
| `-XX:+PrintGCDetails`      | GC 로그 출력             |
| `-XX:+PrintGCDateStamps`   | 로그에 시간 표시            |
| `-Xlog:gc*` (Java 9+)      | GC 로그 통합 출력 방식       |

## GC 알고리즘별 동작 방식 비교표

| GC 이름 | 수집 대상 | 주요 단계 (동작 방식) | 병렬성 | 동시성 | 특징 요약 |
| --- | --- | --- | --- | --- | --- |
| **Serial GC** | Young + Old | **Mark → Sweep → Compact**<br>(모두 단일 스레드, 전체 STW) | ❌ | ❌ | 단순하고 안정적. STW 길지만 구조 단순. 작은 힙에 적합. |
| **Parallel GC** | Young + Old | **Young**: Copying (Eden→Survivor)<br>**Old**: Mark–Compact<br>모두 STW 동안 병렬 수행 | ✅ (멀티스레드) | ❌   | Throughput 우선. STW는 길지만 멀티스레드로 처리 빠름. |
| **CMS (Concurrent Mark-Sweep)** | Old 중심 | ① **Initial Mark (STW)**<br>② **Concurrent Mark (동시)**<br>③ **Concurrent Preclean**<br>④ **Remark (STW)**<br>⑤ **Concurrent Sweep (비압축)** | ✅ | ✅ | 응답속도 중시. 파편화 가능성 존재. Full GC 시 STW 김. |
| **G1 GC (Garbage First)** | Young + Old | ① **Initial Mark (STW)**<br>② **Concurrent Mark**<br>③ **Remark (STW)**<br>④ **Cleanup (STW+Concurrent)**<br>⑤ **Mixed / Young Evacuation (STW)** | ✅ | ✅ | Region 단위 수집, “가비지가 많은 Region”부터 수거. Compact 자동. |
| **ZGC** | 전체 힙 | ① **Mark 시작(STW, 짧음)**<br>② **Concurrent Mark / Relocate / Remap (동시)**<br>③ **Final Mark(STW, 짧음)** | ✅ | ✅ | Color Pointer 기반. STW ≤ 1~2ms. 힙 크기 무관 저지연. |
| **Shenandoah GC** | 전체 힙 | ① **Initial Mark(STW)**<br>② **Concurrent Mark**<br>③ **Final Mark(STW)**<br>④ **Concurrent Evacuation/Compact** | ✅ | ✅ | Load Barrier 방식. ZGC보다 구현 단순, 동시 Compact 수행. |

### 각 단계별 동작 해설

| 단계                  | 설명                                          | 관련 GC                                              |
| ------------------- | ------------------------------------------- | -------------------------------------------------- |
| **Mark (표시)**       | 루트에서 도달 가능한 객체 탐색 및 표시                      | 모든 GC (ZGC, CMS, G1 등은 일부 Concurrent)              |
| **Sweep (제거)**      | 표시되지 않은 객체 제거                               | Serial, CMS (Concurrent Sweep), Parallel           |
| **Compact (압축)**    | 살아남은 객체를 한쪽으로 모아 파편화 방지                     | Serial, Parallel, G1, ZGC, Shenandoah (Concurrent) |
| **Copy (복사)**       | 살아남은 객체를 다른 영역으로 이동 (Eden → Survivor / Old) | Young 영역 (Copying GC)                              |
| **Concurrent Mark** | 애플리케이션 실행과 동시에 객체 생존 여부 계산                  | CMS, G1, ZGC, Shenandoah                           |
| **Evacuation (이동)** | 가비지 많은 리전에서 객체를 다른 리전으로 복사                  | G1, Shenandoah, ZGC                                |
| **Remark**          | 마킹 중 변경된 참조를 최종 반영 (짧은 STW)                 | CMS, G1, Shenandoah, ZGC                           |
| **Cleanup**         | 회수 대상 리전 선택, 불필요한 메타데이터 정리                  | G1, ZGC                                            |
