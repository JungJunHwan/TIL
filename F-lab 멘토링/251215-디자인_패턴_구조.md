# GoF (Gang of Four) 디자인 패턴

## 구조

### 어댑터 패턴 (Adapter Pattern)

- 정의
    - 호환되지 않는 인터페이스를 가진 객체들이 함께 작동할 수 있도록 중간에서 변화해주는 래퍼(Wrapper)를 만드는 패턴

<br>

패턴이 적용되지 않은 코드
- 기존 시스템은 `MediaPlayer` 인터페이스를 사용하는데, 새로 도입하려는 `VideoPlayer`는 메서드 이름도 다르고 호환이 안 됩니다. 이를 사용하려면 기존 코드를 뜯어고쳐야 합니다.

```java
// 기존 시스템의 인터페이스
interface MediaPlayer {
    void play(String filename);
}

// 새로 도입된 외부 라이브러리 (수정 불가하다고 가정)
class VideoPlayer {
    void playVideo(String filename) {
        System.out.println("동영상 재생 중: " + filename);
    }
}

public class Main {
    public static void main(String[] args) {
        MediaPlayer player = ...; 
        
        // 오류! VideoPlayer는 MediaPlayer 인터페이스를 구현하지 않았음
        // player = new VideoPlayer(); 
        
        // 결국 기존 코드를 수정해서 VideoPlayer 객체를 따로 만들고 호출해야 함 (일관성 깨짐)
        VideoPlayer videoPlayer = new VideoPlayer();
        videoPlayer.playVideo("movie.mp4");
    }
}
```

<br>

패턴이 적용된 코드
- `VideoPlayer`를 감싸서 `MediaPlayer`처럼 보이게 만드는 어댑터 클래스를 만듭니다. 기존 시스템 코드를 변경하지 않고도 새로운 라이브러리를 사용할 수 있습니다.

```java
// 1. 타겟 인터페이스 (기존 시스템 표준)
interface MediaPlayer {
    void play(String filename);
}

// 2. 어댑티 (Adaptee, 새로 도입된 호환 안 되는 클래스)
class VideoPlayer {
    void playVideo(String filename) {
        System.out.println("동영상 재생 중: " + filename);
    }
}

// 3. 어댑터 (변환기)
class VideoPlayerAdapter implements MediaPlayer {
    private VideoPlayer videoPlayer;

    public VideoPlayerAdapter(VideoPlayer videoPlayer) {
        this.videoPlayer = videoPlayer;
    }

    @Override
    public void play(String filename) {
        // 내부적으로 VideoPlayer의 메서드로 변환해서 호출
        System.out.print("어댑터 작동: ");
        videoPlayer.playVideo(filename);
    }
}

// 메인 실행
public class Main {
    public static void main(String[] args) {
        // 기존 시스템은 여전히 MediaPlayer 인터페이스만 바라봄
        MediaPlayer player = new VideoPlayerAdapter(new VideoPlayer());
        
        player.play("movie.mp4");
    }
}
```

### 데코레이터 패턴 (Decorator Pattern)

- 정의
    - 객체에 동적으로 새로운 책임(기능)을 추가하는 패턴
    - 기능 확장을 위해 상속을 사용하는 대신, 객체를 감싸는(Wrapper) 방식을 사용

<br>

패턴이 적용되지 않은 코드
- 기능 조합별로 클래스를 다 만들다 보면, 클래스가 폭발적으로 늘어납니다 (Class Explosion).

```java
class Coffee { 
    void cost() { System.out.println("기본 커피 2000원"); }
}

// 우유 추가된 커피
class MilkCoffee extends Coffee { ... }

// 시럽 추가된 커피
class SyrupCoffee extends Coffee { ... }

// 우유 + 시럽 추가된 커피 (상속으로 해결하려면 조합마다 클래스를 만들어야 함)
class MilkAndSyrupCoffee extends Coffee { ... } 

// 여기에 휘핑까지 추가하려면...? MilkAndSyrupAndWhipCoffee ??
```

패턴이 적용된 코드
- 기능(재료)을 별도의 클래스로 분리하고, 마치 마트료시카 인형처럼 객체를 계속 감싸서 기능을 확장합니다.

```java
// 1. 기본 컴포넌트 인터페이스
interface Beverage {
    String getDescription();
    int getCost();
}

// 2. 기본 구현체 (Base)
class Americano implements Beverage {
    @Override
    public String getDescription() { return "아메리카노"; }
    @Override
    public int getCost() { return 2000; }
}

// 3. 데코레이터 (기능 추가를 위한 추상 클래스)
abstract class BeverageDecorator implements Beverage {
    protected Beverage beverage; // 감쌀 대상

    public BeverageDecorator(Beverage beverage) {
        this.beverage = beverage;
    }
}

// 4. 구체적인 데코레이터 (우유 추가)
class MilkAdd extends BeverageDecorator {
    public MilkAdd(Beverage beverage) { super(beverage); }

    @Override
    public String getDescription() {
        return beverage.getDescription() + ", 우유 추가";
    }

    @Override
    public int getCost() {
        return beverage.getCost() + 500; // 가격 추가
    }
}

// 4. 구체적인 데코레이터 (샷 추가)
class ShotAdd extends BeverageDecorator {
    public ShotAdd(Beverage beverage) { super(beverage); }

    @Override
    public String getDescription() {
        return beverage.getDescription() + ", 샷 추가";
    }

    @Override
    public int getCost() {
        return beverage.getCost() + 500;
    }
}

// 메인 실행
public class Main {
    public static void main(String[] args) {
        // 1. 그냥 아메리카노
        Beverage myCoffee = new Americano();
        
        // 2. 샷 추가 (아메리카노를 감쌈)
        myCoffee = new ShotAdd(myCoffee);
        
        // 3. 우유 추가 (샷 추가된 아메리카노를 또 감쌈)
        myCoffee = new MilkAdd(myCoffee);

        // 결과 출력
        System.out.println("메뉴: " + myCoffee.getDescription());
        System.out.println("가격: " + myCoffee.getCost());
        // 출력: 메뉴: 아메리카노, 샷 추가, 우유 추가
        // 출력: 가격: 3000
    }
}
```

### 퍼사드 패턴 (Facade Pattern)

- 정의
    - 복잡한 서브 시스템들의 관계를 감추고, 사용하기 쉽게 단순화된 하나의 인터페이스를 제공하는 패턴
    - 스프링 프레임워크를 사용한다면, `@Service` 클래스가 바로 퍼사드 패턴의 구현체라고 보면 된다

<br>

패턴이 적용되지 않은 코드
- 클라이언트(여기서는 `OrderController`라고 가정)가 모든 하위 서비스들을 직접 알고, 순서에 맞춰서 하나하나 호출해야 합니다. 컨트롤러가 너무 뚱뚱해지고(Fat Controller), 로직 하나만 바뀌어도 컨트롤러를 수정해야 합니다.

```java
// 하위 서브 시스템들 (복잡함)
class InventoryService {
    void checkStock(String productId) { /* 재고 확인 */ }
    void decreaseStock(String productId) { /* 재고 차감 */ }
}

class PaymentService {
    void pay(String cardNo, int amount) { /* 결제 시도 */ }
}

class DeliveryService {
    void arrangeDelivery(String address) { /* 배송 접수 */ }
}

class NotificationService {
    void sendKakaoTalk(String phone, String msg) { /* 알림 발송 */ }
}

// 클라이언트 (컨트롤러)
public class OrderController {
    // 의존성이 너무 많음 (결합도 높음)
    private InventoryService inventory = new InventoryService();
    private PaymentService payment = new PaymentService();
    private DeliveryService delivery = new DeliveryService();
    private NotificationService noti = new NotificationService();

    public void order(String productId, String cardNo, String address) {
        // 컨트롤러가 비즈니스 흐름을 다 꿰고 있어야 함 (부담스러움)
        inventory.checkStock(productId);
        payment.pay(cardNo, 10000);
        inventory.decreaseStock(productId); // 결제 성공 후 재고 차감
        delivery.arrangeDelivery(address);
        noti.sendKakaoTalk("010-1234-5678", "주문 성공!");
        
        System.out.println("주문 처리 완료");
    }
}
```

<br>

패턴이 적용된 코드
- 퍼사드(`ShopFacade`) 클래스를 만들어서 복잡한 흐름을 그 안에 숨깁니다. 클라이언트는 이제 "주문해줘(placeOrder)" 메서드 하나만 호출하면 됩니다. 내부에서 재고 확인을 먼저 하든, 결제를 먼저 하든 클라이언트는 알 필요가 없습니다.

```java
// 1. 퍼사드 클래스 (복잡한 과정을 캡슐화)
// 실무에서는 보통 'Service' 레이어가 이 역할을 수행합니다. (예: OrderProcessingService)
class ShopFacade {
    private InventoryService inventory;
    private PaymentService payment;
    private DeliveryService delivery;
    private NotificationService noti;

    // 생성자를 통해 의존성 주입 (DI)
    public ShopFacade() {
        this.inventory = new InventoryService();
        this.payment = new PaymentService();
        this.delivery = new DeliveryService();
        this.noti = new NotificationService();
    }

    // 단순화된 인터페이스 제공
    public void placeOrder(String productId, String cardNo, String address) {
        System.out.println("=== 주문 프로세스 시작 ===");
        
        // 복잡한 순서와 예외 처리는 여기서 담당
        try {
            inventory.checkStock(productId);
            payment.pay(cardNo, 10000);
            inventory.decreaseStock(productId);
            delivery.arrangeDelivery(address);
            noti.sendKakaoTalk("010-1234-5678", "주문이 정상 처리되었습니다.");
        } catch (Exception e) {
            noti.sendKakaoTalk("010-1234-5678", "주문 실패: " + e.getMessage());
            // 필요한 경우 결제 취소 로직 등 수행
        }
        
        System.out.println("=== 주문 프로세스 종료 ===");
    }
}

// 2. 클라이언트 (컨트롤러)
public class OrderController {
    private ShopFacade shopFacade = new ShopFacade();

    public void order(String productId, String cardNo, String address) {
        // 코드가 획기적으로 단순해짐
        // 내부 로직이 바뀌어도 컨트롤러는 수정할 필요 없음
        shopFacade.placeOrder(productId, cardNo, address);
    }
}

public class Main {
    public static void main(String[] args) {
        OrderController controller = new OrderController();
        controller.order("MACBOOK_PRO", "1234-5678", "서울시 강남구");
    }
}
```

### 프록시 패턴 (Proxy Pattern)

- 정의
    - 실제 객체에 바로 접근하는 것이 아니라, 대리인 객체를 통해 실제 객체에 접근하도록 하는 패턴
    - 주로 보안, 캐싱, 또는 지연 로딩을 위해 사용
    - 스프링 컨테이너가 알아서 프록시 객체를 만들어주기 때문(AOP)에 프록시 클래스를 직접 만들 일이 거의 없다

<br>

패턴이 적용되지 않은 코드
- 사용자가 10명이면 10번 다 무거운 DB 쿼리를 날립니다. (응답시간: 매번 3초)

```java
// 인터페이스
interface AnalysisService {
    String getDailySales(String date);
}

// 실제 구현체 (무거운 DB 작업)
class RealAnalysisService implements AnalysisService {
    @Override
    public String getDailySales(String date) {
        System.out.println(">> [DB] " + date + " 매출 데이터 집계 중... (3초 소요)");
        try {
            Thread.sleep(3000); // 쿼리 지연 시뮬레이션
        } catch (InterruptedException e) { e.printStackTrace(); }
        return date + " 매출: 10억 원";
    }
}

public class Main {
    public static void main(String[] args) {
        AnalysisService service = new RealAnalysisService();

        // 첫 번째 요청: 3초 걸림
        System.out.println(service.getDailySales("2024-01-01")); 
        
        // 두 번째 요청: 또 3초 걸림 (비효율)
        System.out.println(service.getDailySales("2024-01-01"));
    }
}
```

<br>

패턴이 적용된 코드
- 프록시(`ProxyAnalysisService`)를 만듭니다. 이 프록시는 `AnalysisService` 인터페이스를 구현하며, 내부에 `RealAnalysisService`를 품고 있습니다. 요청이 오면 "캐시에 있나?" 먼저 확인하고, 없으면 실제 객체에게 일을 시킵니다.

```java
import java.util.HashMap;
import java.util.Map;

// 1. 공통 인터페이스 (클라이언트는 이것만 봄)
interface AnalysisService {
    String getDailySales(String date);
}

// 2. 실제 객체 (Real Subject) - 비즈니스 로직에만 집중
class RealAnalysisService implements AnalysisService {
    @Override
    public String getDailySales(String date) {
        System.out.println(">> [DB] " + date + " 매출 데이터 쿼리 실행 (무거움!)");
        try {
            Thread.sleep(3000); // 3초 소요
        } catch (InterruptedException e) { e.printStackTrace(); }
        return date + " 매출: 10억 원";
    }
}

// 3. 프록시 객체 (Proxy) - 캐싱 기능 담당 (접근 제어)
class CachedAnalysisService implements AnalysisService {
    private RealAnalysisService realService; // 실제 객체를 대리함
    private Map<String, String> cache = new HashMap<>(); // 간단한 인메모리 캐시

    @Override
    public String getDailySales(String date) {
        // 1. 캐시에 데이터가 있는지 확인 (가벼운 작업)
        if (cache.containsKey(date)) {
            System.out.println(">> [Cache] 캐시에서 즉시 반환 (DB 접근 안함)");
            return cache.get(date);
        }

        // 2. 캐시에 없다면? 실제 객체를 생성하거나 호출 (지연 로딩 가능)
        if (realService == null) {
            realService = new RealAnalysisService();
        }
        
        // 3. 실제 객체에게 일 시키기
        String result = realService.getDailySales(date);
        
        // 4. 결과 캐싱
        cache.put(date, result);
        
        return result;
    }
}

// 4. 클라이언트
public class DashboardController {
    public static void main(String[] args) {
        // 클라이언트는 프록시를 주입받음 (RealService 아님)
        AnalysisService service = new CachedAnalysisService();

        System.out.println("--- 1번째 요청 (사용자 A) ---");
        long start1 = System.currentTimeMillis();
        System.out.println("결과: " + service.getDailySales("2024-01-01"));
        System.out.println("소요 시간: " + (System.currentTimeMillis() - start1) + "ms");

        System.out.println("\n--- 2번째 요청 (사용자 B) ---");
        long start2 = System.currentTimeMillis();
        // DB에 안 가고 프록시가 바로 던져줌
        System.out.println("결과: " + service.getDailySales("2024-01-01")); 
        System.out.println("소요 시간: " + (System.currentTimeMillis() - start2) + "ms");
    }
}
```

### 컴포지트 패턴 (Composite Pattern)

- 정의
    - 객체들을 트리 구조로 구성하여 개별 객체(Leaf)와 복합 객체(Composite)를 동일하게 다루는 패턴

<br>

패턴이 적용되지 않은 코드
- 폴더 안에 파일도 있고 또 다른 폴더도 들어갈 수 있는데, 이 둘을 구분해서 처리해야 하므로 코드가 지저분해집니다.

```java
class File {
    private String name;
    public File(String name) { this.name = name; }
    public void print() { System.out.println("파일: " + name); }
}

class Directory {
    private String name;
    private List<File> files = new ArrayList<>();
    private List<Directory> directories = new ArrayList<>(); // 폴더 리스트를 따로 관리해야 함

    public Directory(String name) { this.name = name; }
    
    public void addFile(File file) { files.add(file); }
    public void addDir(Directory dir) { directories.add(dir); }

    public void print() {
        System.out.println("폴더: " + name);
        // 파일을 출력하고, 또 폴더를 출력하는 로직이 분리됨 (재귀 처리 복잡)
        for (File f : files) f.print();
        for (Directory d : directories) d.print();
    }
}
```

<br>

패턴이 적용된 코드
- 파일과 폴더를 `FileSystemNode`라는 하나의 인터페이스(또는 추상클래스)로 묶습니다. 폴더는 자식으로 `FileSystemNode` 리스트를 가집니다. 이제 파일이든 폴더든 똑같이 `print()`만 호출하면 됩니다.

```java
import java.util.ArrayList;
import java.util.List;

// 1. 컴포넌트 (공통 인터페이스)
interface FileSystemNode {
    void print(); // 공통 동작
}

// 2. Leaf (개별 객체 - 파일)
class File implements FileSystemNode {
    private String name;

    public File(String name) { this.name = name; }

    @Override
    public void print() {
        System.out.println("  [파일] " + name);
    }
}

// 3. Composite (복합 객체 - 폴더)
class Directory implements FileSystemNode {
    private String name;
    // 중요: 자식으로 File이 아니라 공통 인터페이스인 Node를 가짐
    private List<FileSystemNode> children = new ArrayList<>();

    public Directory(String name) { this.name = name; }

    public void add(FileSystemNode node) {
        children.add(node);
    }

    @Override
    public void print() {
        System.out.println("[폴더] " + name);
        // 자식이 파일이든 폴더든 신경 쓰지 않고 print() 위임 (재귀)
        for (FileSystemNode node : children) {
            node.print();
        }
    }
}

// 메인 실행
public class Main {
    public static void main(String[] args) {
        Directory root = new Directory("루트");
        Directory music = new Directory("음악");
        Directory picture = new Directory("사진");

        root.add(music);
        root.add(picture);
        
        music.add(new File("아이유.mp3"));
        music.add(new File("박효신.mp3"));
        
        picture.add(new File("여행.jpg"));

        // 루트만 출력하면 하위의 모든 구조가 똑같이 처리됨
        root.print();
    }
}
```

### 플라이웨이트 패턴 (Flyweight Pattern)

- 정의
    - 많은 수의 유사한 객체를 생성해야 할 때, 공유 가능한 데이터를 분리하여 메모리를 절약하는 패턴

<br>

패턴이 적용되지 않은 코드
- 나무를 심을 때마다 `type`, `color`, `texture` 같은 무거운 데이터를 계속 새롭게 생성합니다. (메모리 낭비 심각)

```java
class Tree {
    // 이 데이터들이 객체마다 중복됨
    private String type;   // "Oak" (4 bytes)
    private String color;  // "Green" (5 bytes)
    private String texture; // "VeryBigImage.png" (1MB라고 가정)
    
    private int x;
    private int y;

    public Tree(String type, String color, String texture, int x, int y) {
        this.type = type;
        this.color = color;
        this.texture = texture;
        this.x = x;
        this.y = y;
    }
}

public class Main {
    public static void main(String[] args) {
        // 100만 그루 생성 시 texture 데이터도 100만 번 복제됨 -> OOM(Out of Memory) 발생 가능
        for(int i=0; i<1000000; i++) {
            new Tree("Oak", "Green", "TextureData...", i, 0);
        }
    }
}
```

<br>

패턴이 적용된 코드
- 변하지 않는 공유 데이터(`TreeType`)와 변하는 데이터(`x, y`)를 분리합니다. `Factory`를 통해 `TreeType`은 딱 한 번만 생성되어 재사용됩니다.

```java
import java.util.HashMap;
import java.util.Map;

// 1. 공유할 객체 (Intrinsic State: 변하지 않는 부분)
class TreeType {
    private String name;
    private String color;
    private String textureData; // 무거운 데이터

    public TreeType(String name, String color, String textureData) {
        this.name = name;
        this.color = color;
        this.textureData = textureData;
    }

    public void draw(int x, int y) {
        System.out.println(name + " 나무를 (" + x + "," + y + ") 위치에 그림. (메모리 주소: " + this.hashCode() + ")");
    }
}

// 2. 팩토리 (객체 관리자)
class TreeFactory {
    // 캐싱을 위한 Map
    private static final Map<String, TreeType> treeTypes = new HashMap<>();

    public static TreeType getTreeType(String name, String color, String texture) {
        // 이미 있는 종류라면 재사용 (핵심)
        if (!treeTypes.containsKey(name)) {
            treeTypes.put(name, new TreeType(name, color, texture));
            System.out.println("새로운 나무 타입 생성: " + name);
        }
        return treeTypes.get(name);
    }
}

// 3. 껍데기 객체 (Extrinsic State: 위치 등 변하는 부분)
class Tree {
    private int x, y;
    private TreeType type; // 공유 객체 참조

    public Tree(int x, int y, TreeType type) {
        this.x = x;
        this.y = y;
        this.type = type;
    }

    public void install() {
        type.draw(x, y); // 그리기는 공유 객체에게 위임하되, 위치 정보만 전달
    }
}

// 메인 실행
public class Main {
    public static void main(String[] args) {
        // 첫 번째 나무: 새로운 타입 생성됨
        TreeType oakType = TreeFactory.getTreeType("Oak", "Green", "BigData");
        Tree tree1 = new Tree(10, 20, oakType);
        tree1.install();

        // 두 번째 나무: 기존 "Oak" 타입 재사용 (메모리 주소 같음)
        TreeType oakType2 = TreeFactory.getTreeType("Oak", "Green", "BigData");
        Tree tree2 = new Tree(50, 60, oakType2);
        tree2.install();
        
        // 반복문으로 100만 개를 만들어도 TreeType 객체는 딱 1개만 존재함
    }
}
```

### 브리지 패턴 (Bridge Pattern)

- 정의
    - 추상화(기능)와 구현(색상, 재질 등)을 분리하여, 두 가지가 독립적으로 확장될 수 있도록 하는 패턴
    - 상속을 남발하면 클래스 개수가 폭발(Class Explosion)하는 문제를 해결해줌

<br>

패턴이 적용되지 않은 코드
- 새로운 모양(Triangle)을 추가하려면 색상별로 클래스를 다 만들어야 하고, 새로운 색상(Green)을 추가하려면 모양별로 클래스를 다 만들어야 합니다.

```java
// 모양
abstract class Shape {}

// 색상 + 모양의 조합 (클래스가 계속 늘어남)
class RedCircle extends Shape {
    void draw() { System.out.println("빨간색 원"); }
}
class BlueCircle extends Shape {
    void draw() { System.out.println("파란색 원"); }
}
class RedSquare extends Shape {
    void draw() { System.out.println("빨간색 사각형"); }
}
class BlueSquare extends Shape {
    void draw() { System.out.println("파란색 사각형"); }
}
// Green을 추가하려면 GreenCircle, GreenSquare 또 만들어야 함...
```

<br>

패턴이 적용된 코드
- `Color` 인터페이스를 만들고 `Shape`가 이를 사용하게 합니다(다리 놓기). 이제 색상이나 모양을 자유롭게 추가해도 서로 영향을 주지 않습니다.

```java
// 1. 구현부 인터페이스 (Color)
interface Color {
    String fill();
}

// 구체적인 색상들
class Red implements Color {
    public String fill() { return "빨간색"; }
}
class Blue implements Color {
    public String fill() { return "파란색"; }
}

// 2. 추상화부 (Shape) - 브리지 역할
abstract class Shape {
    protected Color color; // 이것이 Bridge! (구현부를 가지고 있음)

    public Shape(Color color) {
        this.color = color;
    }
    abstract void draw();
}

// 구체적인 모양들 (색상이 무엇인지 신경 안 씀, 그냥 color.fill() 호출)
class Circle extends Shape {
    public Circle(Color color) { super(color); }

    @Override
    void draw() {
        System.out.println(color.fill() + " 원을 그립니다.");
    }
}

class Square extends Shape {
    public Square(Color color) { super(color); }

    @Override
    void draw() {
        System.out.println(color.fill() + " 사각형을 그립니다.");
    }
}

// 메인 실행
public class Main {
    public static void main(String[] args) {
        // 모양과 색상을 내 맘대로 조합 가능 (M * N이 아니라 M + N)
        Shape s1 = new Circle(new Red());
        Shape s2 = new Square(new Blue());

        s1.draw(); // 빨간색 원을 그립니다.
        s2.draw(); // 파란색 사각형을 그립니다.
    }
}
```