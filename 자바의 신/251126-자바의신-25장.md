# Thread

## 스레드란?

- 프로세스 : 실행 중인 프로그램 1개
- 스레드 : 프로세스 안에서 실제로 코드를 실행하는 작업 흐름
- 프로세스 vs 스레드
    - 공통점
        - 둘 다 CPU가 번갈아가며 실행하는 단위 (컨텍스트 스위칭)
    - 차이점
        - 프로세스끼리 메모리를 공유하지 않음
        - 스레드끼리 같은 프로세스 안의 힙, 메소드 영역을 공유하지만 각자 자기 스택을 가짐
        - 공유하는 것
            - Heap / Metaspace / Method Area / Runtime Constant Pool / Code Cache 등
        - 각 스레드마다 따로 있는 것
            - Java Stack / PC Register
- 스택 변수는 스레드끼리 안 섞임
- 하지만 힙에 있는 객체는 모든 스레드가 동시에 건드릴 수 있어서 동기화 문제가 생김

## JVM 메모리 구조와 엮어서 보는 스레드/프로세스

- 프로세스(=JVM 전체) 수준에서 공유하는 영역
    - Heap
    - Metaspace
    - Code Cache
    - Direct Memory(Off-heap)
- 스레드마다 따로 있는 영역
    - Java Stack
    - PC Register
    - Native method Stack

그래서

1. 하나의 JVM 프로세스 안에 여러 스레드가 있을 때
    - 모든 스레드는 같은 Heap / Metaspace를 본다
        - 힙에 올라간 객체는 모든 스레드가 공유 가능
        - 그래서 경쟁 조건, 동시성 문제가 발생
    - 하지만 각 스레드는 자기만의 스택을 사용
        - 이 스택 안에는 그 스레드의 지역 변수, 호출 스택만 있음
        - 다른 스레드와 스택을 공유하지 않기 때문에, 지역 변수는 기본적으로 스레드 안전하다
2. 프로세스 단위로 JVM이 여러 개 뜨면
    - Heap / Metaspace 도 프로세스마다 완전히 분리
    - 서로의 객체를 직접 볼 수 없음
    - 서로의 객체를 보려면 프로세스 간 통신(소켓, 파일, DB, 메시지 큐 등)을 써야함

## 스레드 만드는 방법

### Thread 상속

```java
class MyThread extends Thread {
    @Override
    public void run() {
        // 스레드가 해야 할 작업
        for (int i = 0; i < 5; i++) {
            System.out.println("MyThread: " + i);
        }
    }
}

public class Main {
    public static void main(String[] args) {
        MyThread t = new MyThread();
        t.start();  // 꼭 run()이 아니라 start()를 호출해야 새 스레드가 만들어짐

        System.out.println("main thread 끝");
    }
}
```

- `start()`를 호출하면 JVM이 새 스레드 하나 생성하고, 그 스레드가 `run()` 메서드를 실행
- `run()`을 직접 호출하면 새 스레드 없이 현재 스레드에서 그냥 메서드 호출

### Runnable 구현

```java
class MyTask implements Runnable {
    @Override
    public void run() {
        System.out.println("작업 실행!");
    }
}

public class Main {
    public static void main(String[] args) {
        Thread t = new Thread(new MyTask());
        t.start();
    }
}
```

또는 람다

```java
Thread t = new Thread(() -> {
    System.out.println("람다로 실행");
});
t.start();
```

### 스레드 풀 (ExecutorService)

```java
import java.util.concurrent.*;

ExecutorService executor = Executors.newFixedThreadPool(4);

executor.submit(() -> {
    System.out.println("스레드 풀에서 돌리는 작업");
});

// 더 이상 안 쓸 때
executor.shutdown();
```

## 스레드의 라이프사이클

1. NEW : `new Thread(...)` 했지만 아직 `start()` 안 한 상태
2. RUNNABLE : 실행 가능한 상태 (실행 중이거나, 실행 대기)
3. BLOCKED : `synchronized` 락을 얻으려고 기다리는 상태
4. WAITING / TIMED_WAITING : `wait()`, `join()`, `sleep()` 등으로 기다리는 상태
5. TERMINATED : `run()` 메소드가 끝난 상태

## 스레드에서 자주 발생하는 문제들

### 레이스 컨디션

여러 스레드가 같은 공유 데이터를 동시에 수정해서, 실행 순서에 따라 결과가 달라지는 상황

```java
class Counter {
    public int value = 0;

    public void increment() {
        value++;  // 읽고, +1하고, 다시 쓰는 3단계가 있음
    }
}
```

- 스레드 2개가 동시에 `increment()`를 호출하면
    - 둘 다 0을 읽고
    - 둘 다 1을 증가시키는 식으로
    - 실제로는 2번 증가해야하나 값은 1이 될 수 있다

### 가시성 문제

CPU / JVM이 최적화하면서, 한 스레드가 변경한 값이 다른 스레드에게 바로 보이지 않을 수 있음

```java
class Flag {
    boolean running = true;

    void run() {
        while (running) {
            // do something
        }
    }
}
```

캐시된 값을 계속 보는 문제로 인해 다른 스레드에서 `running = false`를 했는데도 while 루프가 영원히 끝나지 않을 수 있음

- 해결 방법
    - `volatile` 키워드 사용
    - 또는 `synchronized`, `Lock` 같은 동기화 기법 사용

### 데드락 (Deadlock)

서로가 서로의 락을 기다리느라 영원히 멈춰버리는 상황

```java
synchronized (a) {
    synchronized (b) {
        // ...
    }
}
```

다른 스레드가

```java
synchronized (b) {
    synchronized (a) {
        // ...
    }
}
```

이렇게 하면 스레드 1은 a를 잡고 b를 기다리고, 스레드 2는 b를 잡고 a를 기다리게되어 둘 다 영원히 기다린다

## 면접 질문

### 프로세스와 스레드의 차이를 설명하라

나의 답변
- 프로세스는 실행 중인 프로그램 하나를 말하며 스레드는 실제 작업 흐름이다. 프로세스 간에는 데이터의 공유가 없지만, 스레드끼리는 힙, 메타스페이스 등 같은 메모리 영역을 공유한다. 또한, 프로세스 간에 스레드는 공유하지 않고, 하나의 프로세스는 여러개의 스레드를 가질 수 있다

다듬은 버전
- 프로세스는 실행 중인 프로그램 하나를 의미하고, 스레드는 그 안에서 실제로 코드를 실행하는 흐름 단위입니다
- 프로세스는 독립된 메모리 공간을 가지기 때문에 서로 메모리를 공유하지 않지만, 하나의 프로세스 내부 스레드들은 힙과 메소드 영역 같은 공용 메모리를 공유합니다
- 반면, 스레드는 각자 자신의 스택과 PC Register를 가지며 호출 상태는 독립적으로 유지됩니다
- 하나의 프로세스는 여러 스레드를 가질 수 있고, 이러한 스레드들이 같은 메모리 공간을 공유하기 때문에 동시성 문제가 발생할 수 있습니다

### 스레드를 직접 생성하는 방식은 왜 실무에서는 잘 사용하지 않나요?

나의 답변
- 모르겠습니다

모범 답변
- 실무에서는 스레드를 직접 생성하는 방식은 거의 사용하지 않습니다. 스레드는 생성 비용이 높고, 한 번만 실행할 수 있으며, 직접 만들면 스레드 개수나 예외, 트랜잭션, 보안 컨텍스트를 프레임워크가 관리할 수 없기 때문입니다.
- 대신 실무에서는 스레드 풀 기반의 ExecutorService나 Spring의 @Async를 사용합니다. 스레드 풀은 스레드를 재사용하고, 스레드 개수를 제안할 수 있어 성능과 안정성이 보장됩니다. 또한 프레임워크 레벨에서 예외 처리, 모니터링, 컨텍스트 전파 등을 일관성 있게 관리할 수 있습니다

### 스택과 힙에서 스레드는 어떻게 메모리를 사용하나요?

나의 답변
- 모르겠습니다

모범 답변
- 스레드가 생성되면 JVM은 스레드마다 독립적인 스택을 할당합니다. 스택에서는 지역 변수, 메서드 호출 프레임 등이 저장되기 때문에 다른 스레드와 공유되지 않습니다. 반면, new로 생성되는 객체는 모두 힙에 저장되며 힙은 모든 스레드가 공유하는 메모리 영역입니다.
- 따라서 여러 스레드가 동일한 힙 객체에 동시에 접근할 수 있기 때문에 경쟁 상태, 가시성 문제 등의 동시성 문제가 발생합니다. 이를 해결하기 위해 synchronized, Lock, volatile 같은 동기화 기법이 필요합니다

### synchronized 키워드는 어떤 방식으로 동작하나요?

나의 답변
- synchronized는 한 스레드가 synchronized 처리된 메소드를 실행중일때 다른 스레드가 해당 메소드를 실행하지 못하게 막는 방식으로 작동합니다

모범 답변
- synchronized는 하나의 객체 모니터에 대해 단 하나의 스레드만 진입할 수 있도록 하는 상호 배제(Mutual Exclusion) 메커니즘입니다.
- JVM은 synchronized 블록이나 메소드에 진입할 때 해당 객체의 모니터 락을 획득하고, 블록을 빠져나올때 락을 해제합니다.
- 다른 스레드는 락이 해제될 때까지 BLOCKED 상태로 대기합니다
- 또한 synchronized는 단순한 배타적 실행뿐 아니라 메모리 가시성도 보장합니다
- 락을 획득할 때는 다른 스레드가 변경한 값을 메인 메모리에서 읽어오고, 락을 해제할 때는 쓰기 연산이 메인 메모리에 반영됩니다.
- 즉, Java Memory Model의 happens-before 관계를 만족하여 원자성, 가시성 문제를 해결합니다

### 자바에서 volatile 키워드는 어떤 문제를 해결하며, synchronized와 어떤 차이가 있나요?

나의 답변
- 모르겠습니다

모범 답변
- volatile은 메모리 가시성 문제를 해결하기 위한 키워드로, 한 스레드가 volatile 변수에 쓴 값이 다른 스레드에서 즉시 보이도록 보장합니다. 또한 명령어 재배치를 금지하여 happens-before 관계를 형성합니다. 하지만 volatile은 원자성을 보장하지 않기 때문에 복합 연산에서는 여전히 동시성 문제가 발생할 수 있습니다
- 반면 synchronized는 모니터 락을 기반으로 상호 배제를 보장하며, 원자성/가시성/재배열 방지 모두를 제공합니다
- 즉, volatile은 단순한 플래그나 상태변수에 적합하고, 공유 자원의 안전한 변경이 필요하면 synchronized를 사용합니다

synchronized와 volatile의 차이

| 구분                  | volatile | synchronized        |
| ------------------- | -------- | ------------------- |
| 가시성(Visibility) | O        | O                   |
| 원자성(Atomicity)  | X        | O                   |
| 락(Lock)         | 없음       | 모니터 락 사용            |
| 성능              | 빠름       | 상대적으로 느림            |
| 목적              | 최신 값 보장  | 코드 영역 전체의 안전한 진입 보장 |
| 재정렬 방지          | O        | O                   |

정리
- volatile : 최신 값 보장 + 재배치 금지 (가벼움)
- synchronized : 원자성 + 상호배제 + 가시성 모두 보장 (무거움)

### Java Memory Model(JMM)의 happens-before 관계란 무엇이며, 왜 중요할까요?

나의 답변
- 모르겠습니다

모범 답변
- happens-before는 JMM에서 두 연산 간의 가시성과 순서를 보장하는 규칙입니다
- 하나의 연산이 다른 연산보다 먼제 일어난 것이 보장되면, 첫번째 연산의 결과각 두 번째 연산에서 반드시 보이고, 명령어 재배치도 허용되지 않습니다
- 예를 들어, synchronized 블록의 unlock은 이후에 같은 락을 획득한 스레드의 lock보다 happens-before이므로 가시성과 순서가 보장됩니다
- volatile write -> volatile read도 동일합니다
- 이 규칙 덕분에 멀티스레드 환경에서 일관성을 유지할 수 있습니다

이론

- happens-before란 한 스레드의 특정 동작이 다른 스레드에서 반드시 보인다는 메모리 가시성/순서 보장 규칙이다
- happens-before는 다음의 2가지를 보장한다 (A가 happens-before B 라고 할 때)
    1. 가시성 : A가 메모리에 쓴 값이 B에서 반드시 보인다
    2. 순서 : A의 모든 연산이 B 이전에 실행된 것처럼 보장된다
- happens-before가 만들어지는 대표 규칙
    1. 모든 같은 스레드에서의 프로그램 순서
        - 같은 스레드 안에서는 순서대로 실행된 것처럼 보임
    2. Monitor Lock (synchronized)
        - unlock -> lock은 happens-before 관계
    3. volatile
        - volatile write -> volatile read
    4. 스레드 생명주기
        - Thread.start() 이전 작업 -> run() 내부 작업
        - run() 내부 작업 -> Thread.join() 이후 작업
    5. Transitivity (전이성)
        - A happens-before B
        - B happens-before C
        - then A happens-before C

### 왜 synchronized 대신 ReentrantLock을 사용하는가?

나의 답변
- 모르겠습니다

모범 답변
- ReentrantLock은 synchronized보다 더 세밀한 락 제어 기능을 제공합니다. 예를 들어 tryLock()을 통해 락을 즉시 또는 일정 시간만 시도할 수 있고, lockInterruptibly()로 대기 중인 스레드를 interrupt로 깨울 수도 있습니다. 또한 조건 변수(Condition)를 여러 개 만들 수 있어 wait/notify 보다 더 정교한 동기화가 가능합니다
- 또한 공정(Fair) 모드와 비공정(Unfair) 모드를 선택할 수 있어 스레드간 starvation을 방지할 수 있습니다. 이런 기능들은 synchronized에서는 제공되지 않기 때문에 실무에서는 복잡한 동시성 제어가 필요할 때 ReentrantLock을 사용합니다

이론
- synchronized는 언어 차원의 모니터 락
- ReentrantLock은 java.util.concurrent에서 제공하는 고급 락
- ReentrantLock이 synchronized보다 좋은 이유
    1. tryLock()
        - 락을 기다리지 않고 즉시 획득 시도 가능
        - synchronized에서는 절대 불가능함
    2. tryLock(timeout)
        - 일정 시간만 대기하고 포기 가능
        - synchronized는 무한정 블록됨 -> 데드락 위험 증가
    3. interruptible lock acquisition
        - 락이 걸린 상태에서 `lock.lockInterruptibly()` 사용하면 `interrupt()`로 대기 중 스레드를 깰 수 있음
        - synchronized는 블록 상태를 interrupt 할 수 없음
    4. 공정성 지원 (Fair lock)
        - 락을 요청한 순서대로 처리 (먼저 온 스레드 먼저 처리)
        - synchronized는 기본적으로 비공정 락
    5. Condition 객체 사용 가능
        - wait/notify보다 더 세밀한 조건 대기/신호 제어 가능
        - `Condition condition = lock.newCondition();`
        - 이렇게 여러 조건변수를 만들어 각각 다른 대기 그룹을 관리할 수 있음
        - synchronized는 단 하나의 wait/notify 집합만 존재
    6. 모니터 락 구조 상세 관리 가능
        - synchronized : JVM이 관리
        - ReentrantLock : 개발자가 명확히 `lock()` / `unlock()` 관리
        - -> 락 해제 시점을 자유롭게 제어 가능
- ReentrantLock의 단점
    - 직접 unlock() 호출해야 하므로 실수하면 데드락 위험
    - 코드가 복잡해짐
    - JIT 최적화 상황에 따라 synchronized보다 약간 느린 경우도 있다