# 8장

## 생성자 없이 객체를 얻을 수 있는 클래스

생성자는 객체를 생성하기 위한 존재이지만, 생성자 없이 객체를 얻을 수 있는 클래스가 있다

1. 싱글톤 패턴 클래스
    - 생성자를 `private`로 막아두고 정적 메서드로 객체를 얻는 클래스
    - new를 외부에서 못하므로 생성자가 없는 것처럼 보임
    - 예)

```java
public class Singleton {
    private static final Singleton instance = new Singleton(); 
    private Singleton() {}   // 외부에서 못씀

    public static Singleton getInstance() {
        return instance;
    }
}
```

2. static factory method로 객체를 제공하는 클래스

- 생성자 대신 정적 팩터리 메서드로 객체를 반환
- 예)

```java
public class Hello {
    private Hello() {}
    public static Hello of() {
        return new Hello();
    }
}
```

- JDK에서 자주 쓰인다
    - `List.of()`, `LocalDate.now()`, `Optional.of()` 등이 다 이런 방식이다

## 생성자 없이 객체가 필요한 이유

1. 객체 생성을 통제
2. 객체 생성 비용이 크기 때문 (재사용 목적)
    - 정적 메서드 또는 팩토리에서 캐싱하여 재사용한다
3. 생성자보다 더 의미 있는 이름을 가지고 싶기 때문
    - 생성자 이름은 클래스 이름과 같아서 의미를 표현하기 어렵다
    - 예)
        - ```java
            new BigInteger(130, random);
            ```
        - 정적 팩토리 사용 시
        - ```java
            BigInteger.probablePrime(130,random);
            ```
    - 훨씬 읽기 좋고, 의도가 명확하다
4. 여러 종류의 객체를 상황에 따라 반환할 수 있기 때문
    - 생성자는 항상 해당 클래스의 객체만 만든다
    - 하지만 정적 팩터리 클래스는 상황에 따라 다른 하위 타입 객체를 리턴할 수 있다
    - 예)
```java
public interface Shape {
    static Shape of(String type) {
        return switch(type) {
            case "circle" -> new Circle();
            case "square" -> new Square();
            default -> throw ...
        };
    }
}
```
5. 불변(Immutable) 객체를 쉽게 만들기 위해
    - 불변 객체는 상태가 바뀌지 않기 때문에 한 번 생성된 객체를 재사용하거나 내부적으로 공유하는게 좋다

## 메소드 오버로딩

- 메소드 오버로딩 시 주의점
    - 같아야 하는 것 : 메소드 명
    - 달라야 하는 것 : 매개변수
    - 상관없는 것 : 반환 타입, 접근제어자, throws

## static 블록

- 클래스 로딩 시 딱 한 번만 실행해야 하는 초기화 작업
    - 복잡한 static 변수 초기화
    - 상수 테이블(Immutable Map) 미리 채우기

## Pass by Value / Pass by reference

- Pass by Value
    - 값을 복사해서 넘긴다
- Pass by Reference
    - 원본 자체(참조)를 넘겨서 원본을 직접 건드릴 수 있다
- 자바는 Pass by Value만 있다
- 예) Pass by Value

```java
class Counter {
    int value;
}

void increment(Counter c) {
    c.value++;
}

Counter c1 = new Counter();
c1.value = 10;

increment(c1);
System.out.println(c1.value); // 11
```

- 이 예시에서는 c1의 value가 10에서 11로 바뀌므로 참조로 전달된 것으로 생각할 수 있다
- 하지만, 실제로는 다음과 같이 수행된다
    1. `c1`에는 객체의 참조값이 들어가 있다
    2. 메서드 호출 시, 이 참조값이 복사되어 매개변수 c에 들어간다
    3. 두 변수 `c1`, `c`는 같은 객체를 가리키는 서로 다른 복사본을 참조한다
    4. `c.value++` 하면, 그 참조가 가리키는 객체 내부가 바뀐다
- 다음의 예시를 보자

```java
void change(Counter c) {
    c = new Counter();
    c.value = 999;
}

Counter c1 = new Counter();
c1.value = 10;

change(c1);
System.out.println(c1.value); // 10
```

- 만약 java가 Pass by Reference였다면 `change`에서 `c`는 곧 `c1`이고, `c`에 새로운 `Counter` 객체가 할당되었기 때문에 `c`에 새로운 객체의 참조가 들어가 `c1`의 `value`도 `999`로 바뀌어야 한다
- 하지만 실제 결과는 `10`인데, 그 이유는 자바는 Pass by Value이기 때문에 `c`에는 `c1`의 참조가 그대로 전달되는 것이 아닌 `c1`의 참조 값의 복사본이 들어가기 때문에 `change`에서 `c`에 새로운 객체가 할당될 때 `c1`과 `c`는 서로 다른 참조값을 가지게 되어 서로 다른 객체를 가리키게 되어 `c1`의 `value`가 변하지 않는다