# 컬렉션 (Map)

## Map이란?

- `java.util.Map<K ,V>`는 Key -> Value 형태로 데이터를 저장하는 자료구조이다
- Key는 중복이 안되지만 Value는 중복이 가능하다
- Key 기반 검색이 매우 빠르다

## Map의 구현체

### HashMap

- 내부는 배열 + 해시 버킷 + (Java 8 이후) 트리 구조 조합
    - 데이터를 저장하는 기본 단위는 Node<K, V> 배열
    - 같은 해시 버킷에 여러 개가 들어가면 LinkedList나 Red-Black Tree로 저장됨
- 순서 보장하지 않음
- 해쉬 충돌을 제외하곤 O(1)
- 저장 순서
    - `hashCode()`로 객체의 해시값 계산
    - 해시값으로 버킷 위치 결정
    - 그 위치에 노드를 연결(LinkedList 또는 트리)
- Java 8 이후 성능 향상
    - 해시 충돌이 많아 LinkedList가 길어지면 Red-Black Tree로 자동 변환해, 최악 시간 복잡도가 O(n) -> O(log n)으로 개선된다

### LinkedHashMap

- HashMap과 동일하지만 내부에 이중 연결 리스트가 추가되어 삽입 순서가 유지된다

### TreeMap

- 정렬된 Map
- 내부 구조는 Red-Black Tree (이진 검색 트리)
- 항상 정렬된 키 순서로 저장
- 키는 Comparable 또는 Comparator 필요
- 성능 : O(log n)

### ConcurrentHashMap

- thread-safe + 고성능
- synchronized 전체 락이 아님
- segment(부분) 락 / CAS 연산 사용
    - CAS(Compare-And-Swap 또는 Compare-And-Set)은 락을 걸지 않고도 여러 스레드가 동시에 안전하게 값을 갱신할 수 있게 해주는 원자적 연산이다
    - 현재 값이 내가 알고 있던 값이면 바꾸고, 아니면 실패한다
- 자바 8 이전 구조
    - 여러 개의 Segment가 있었음
    - Segment마다 ReentrantLock으로 락을 걸었음
    - 병렬성은 Segment 개수에 의해 제한됨
- 자바 8 이후 구조
    - put/get은 대부분 CAS로 수행
    - 충돌 버킷을 LinkedList -> RBT로 변환
    - 확장은 여러 스레드가 협렵해서 병렬로 수행
    - synchronized 사용하더라도 전체 맵을 잠그지 않고 버킷 단위로만 잠그므로 병렬성 극대화
    - null key / null value 금지
- HashMap처럼 빠름
- 멀티스레드 환경에서는 무조건 ConcurrentHashMap

## Map 주의점

1. Key에 커스텀 객체 사용 + equals/hashCode 미구현
2. TreeMap에 순서를 넣었는데 Comparable 구현 안함
    - ClassCastException 발생
3. 반복문에서 map.put()로 구조 변경
    - ConcurrentModificationException 주의