# 15장 String

---

## String 클래스의 선언

```java
public final class String extends Object implements Serializable, Comparable<String>, CharSequence
```

- public : 누구나 다 사용할 수 있는 클래스
- final : 더 이상 확장할 수 없는 클래스
- Serializable : 이 인터페이스는 구현해야 하는 메소드가 하나도 없다. 이를 구현한다고 선언하면, 해당 객체를 파일로 저장하거나 다른 서버에 전송 가능한 상태가 된다
- Comparable : compareTo()라는 메소드 하나만 선언되어 있다. 선언문의 <> 안에 String이라고 적었는데 이는 Generic을 의미한다
- CharSequeance : 이 인터페이스는 해당 클래스가 문자열을 다루기 위한 클래스라는 것을 명시적으로 나타내는 데 사용된다

---

## String의 생성자

```java
String name = "junhwan";
String name = new String("junhwan");
```
- 이 두 가지 방식 모두 사용 가능하지만 new를 이용해 생성된 객체는 해당 변수에 새로운 값이 할당되자마자 가비지 컬렉터의 대상이 되기 때문에 가장 의미가 없는 생성자이다
```java
String(byte[] bytes)
String(byte[] bytes, String charsetName) //charset : 문자의 집합을 의미하며, 특정 나라의 글자를 의미
```
- 이 두가지를 가장 많이 사용한다

---

## String 문자열을 byte로 변환

```java
byte[] getBytes()
byte[] getBytes(Charset charset)
byte[] getBytes(String charsetName)
```
- 캐릭터 셋을 잘 알고 있거나, 같은 프로그램 내에서 문자열을 byte 배열로 만들 때는 매개 변수가 없는걸 사용하면 됨
- 하지만, 다른 시스템에서 전달 받은 문자열을 byte 배열로 변환할 때는 문자열이 다른 캐릭터 셋으로 되어 있을 수 있기 때문에 2, 3번째의 메소드를 사용하는 것이 좋다
- java.nio.Charset 클래스 APi에는 표준 캐릭터 셋이 정해져 있다
- 사용 예시
```java
String korean = "한글";
byte[] byteKor = korean.getBytes("UTF-16");
String newKorean = new String(byteKor);
```
- 이때 캐릭터 셋이 다르면 글자가 깨질 수도 있다

---

## 절대로 사용하면 안되는 메소드 intern()

- 이 메소드는 자바로 구현되지 않고 C로 구현되어 있는 native 메소드 중 하나다
- native 메소드이기 때문에 쓰지 말라는 것이 아닌, 시스템의 심각한 성능 저하를 발생시킬 수도 있기 때문이다

```java
String a = "java";
String b = "java";
String c = new String("java");

System.out.println(a == b); //true
System.out.println(a == c); //false
System.out.println(a.equals(c)); //true
```
- a, b와 같이 객체를 생성하면 String 클래스에서 관리하는 문자열 풀(pool)에 해당 값이 있으면 기존에 있는 객체를 참조하고 c와 같이 객체를 생성하면 같은 문자열이 풀에 있던 말던 새로운 객체를 생성한다
- 이때 해당 코드를 아래와 같이 변경하면
```java
String a = "java";
String b = "java";
String c = new String("java");

c = c.intern();

System.out.println(a == b); //true
System.out.println(a == c); //true
System.out.println(a.equals(c)); //true
```
- intern() 메소드를 수행하면 new String() 으로 생성한 문자열 객체라고 해도, 풀에 해당 값이 있으면, 풀에 있는 값을 참조하는 객체를 리턴한다
- 만약 동일한 문자열이 존재하지 않으면 풀에 해당 값을 추가한다
- 따라서, intern() 메소드를 수행한 뒤의 문자열은 equals() 메소드가 아닌, == 으로도 동일한지 비교할 수 있다

- equals() 와 == 으로 비교하는 것의 성능 차이는 많다
- == 으로 비교하는 것이 더욱 빠르다

- 이 메소드를 사용하지 말아야 하는 이유는 다음과 같다
  - 새로운 문자열을 쉴새 없이 만드는 프로그램에서 이 메소드를 사용하여 억지로 문자열 풀에 값을 할당하도록 만들면, 저장되는 연역은 한계가 있기 때문에 그 영역에 대해서 별도의 메모리를 청소하는 단계를 거친다
  - 따라서, 작은 연산 하나를 빠르게 하기 위해서 전체 자바 시스템의 성능에 악영향을 주게 된다

---

## immutable한 String의 단점을 보완하는 StringBuffer, StringBuilder

- String 객체는 변하지 않는다
  - String 문자열을 더하면 새로운 객체가 생성되고, 기존 객체는 버려진다
- 이를 보완하기 위한 클래스가 StringBuffer, StringBuilder이다
  - 두 클래스가 제공하는 메소드는 동일하다
  - 하지만 StringBuffer는 Thread safe하고, StringBuilder는 Thread safe하지 않다
    - 기능은 같지만 StringBuffer가 더 안전하고, StringBuilder가 더 빠르다
  - 언제 StringBuffer를 사용하고, 언제 StringBuilder 클래스를 사용해야 할까?
    - 일반적으로 하나의 메소드 내에서 문자열을 생성하여 더할 경우에는 StringBuilder를 사용해도 전혀 상관이 없다
    - 하지만, 어떤 클래스에 인스턴스 변수가 선언되었고, 여러 쓰레드에서 이 변수에 동시 접근하는 일이 있을 경우에는 반드시 StringBuffer를 사용해야 한다
- String, StringBuffer, StringBuilder의 공통점
  - 모두 문자열을 다룬다
  - CharSequence 인터페이스를 구현했다
  -   이 세 가지 클래스 중 하나의 클래스를 사용해 매개 변수를 받는 작업을 할 때 CharSequence 타입으로 받는 것이 좋다
